package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

import java.io.*;
import java.util.LinkedList;
import java.util.Collection;
import java.util.Iterator;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.mj.runtime.*;
import rs.etf.pp1.symboltable.structure.HashTableDataStructure;
import rs.etf.pp1.symboltable.visitors.SymbolTableVisitor;

parser code {:

    public static class DumpUpgradeSymbolTableVisitor extends SymbolTableVisitor
    {
        protected StringBuilder output = new StringBuilder();
        protected final String indent = "   ";
        protected StringBuilder currentIndent = new StringBuilder();

        protected void nextIndentationLevel() {
            currentIndent.append(indent);
        }

        protected void previousIndentationLevel() {
            if (currentIndent.length() > 0)
                currentIndent.setLength(currentIndent.length()-indent.length());
        }

        @Override
        public void visitObjNode(Obj objToVisit) {
            //output.append("[");
            switch (objToVisit.getKind()) {
            case Obj.Con:  output.append("Con "); break;
            case Obj.Var:  output.append("Var "); break;
            case Obj.Type: output.append("Type "); break;
            case Obj.Meth: output.append("Meth "); break;
            case Obj.Fld:  output.append("Fld "); break;
            case Obj.Prog: output.append("Prog "); break;
            }

            output.append(objToVisit.getName());
            if (objToVisit.getKind() == Obj.Type && objToVisit.getType().getKind() == Struct.Class)
            {
                output.append(", " + objToVisit.getType());
            }
            output.append(": ");

            if ( ((objToVisit.getKind() == Obj.Meth) || (objToVisit.getKind() == Obj.Var) || (objToVisit.getKind() == Obj.Fld)) && (objToVisit.getType().getKind() == Struct.Class))
            {
                output.append("Class ");
                output.append(objToVisit.getType());
            }
            else
            {
                objToVisit.getType().accept(this);
            }
            output.append(", ");
            output.append("Adr:" + objToVisit.getAdr());
            output.append(", ");
            output.append("Level:" + objToVisit.getLevel() + " ");
            output.append(", ");
            output.append("FormParPos:" + objToVisit.getFpPos() + " ");

            if (objToVisit.getKind() == Obj.Meth)
            {
                if (isMethodStatic(objToVisit))
                {
                    output.append(", static method");
                }

                if (isMethodGlobal(objToVisit))
                {
                    output.append(", global function");
                }
                if (isMethodVirtual(objToVisit))
                {
                    output.append(", virtual method");
                    if (doesMethodOverride(objToVisit))
                    {
                        output.append(", overidden method");
                    }
                }
            }

            if (objToVisit.getKind() == Obj.Prog || objToVisit.getKind() == Obj.Meth) {
                output.append("\n");
                nextIndentationLevel();
            }

            for (Obj o : objToVisit.getLocalSymbols()) {
                output.append(currentIndent.toString());

                if ((objToVisit.getKind() == Obj.Meth) && (o.getType().getKind() == Struct.Class))
                {
                    output.append("Var ");
                    output.append(o.getName());
                    output.append(": ");
                    output.append("Class ");
                    output.append(o.getType());
                    output.append(", ");
                    output.append("Adr:" + o.getAdr());
                    output.append(", ");
                    output.append("Level:" + o.getLevel() + " ");
                    output.append(", ");
                    output.append("FormParPos:" + o.getFpPos() + " ");
                }
                else
                {
                    o.accept(this);
                }
                output.append("\n");
            }

            if (objToVisit.getKind() == Obj.Prog || objToVisit.getKind() == Obj.Meth)
                previousIndentationLevel();

            //output.append("]");
        }

        /* (non-Javadoc)
         * @see rs.etf.pp1.symboltable.test.SymbolTableVisitor#visitScopeNode(symboltable.Scope)
         */
        @Override
        public void visitScopeNode(Scope scope) {
            for (Obj o : scope.values()) {
                o.accept(this);
                output.append("\n");
            }
        }

        /* (non-Javadoc)
         * @see rs.etf.pp1.symboltable.test.SymbolTableVisitor#visitStructNode(symboltable.Struct)
         */
        @Override
        public void visitStructNode(Struct structToVisit) {
            switch (structToVisit.getKind()) {
            case Struct.None:
                output.append("notype");
                break;
            case Struct.Int:
                output.append("int");
                break;
            case Struct.Char:
                output.append("char");
                break;
            case Struct.Bool:
                output.append("bool");
                break;
            case Struct.Array:
                output.append("Arr of ");

                switch (structToVisit.getElemType().getKind()) {
                case Struct.None:
                    output.append("notype");
                    break;
                case Struct.Int:
                    output.append("int");
                    break;
                case Struct.Char:
                    output.append("char");
                    break;
                case Struct.Class:
                    output.append("Class ");
                    output.append(structToVisit.getElemType());
                    break;
                case Struct.Bool:
                  output.append("bool");
                    break;
                }
                break;
            case Struct.Class:
                output.append("Class [\n");
                nextIndentationLevel();
                for (Obj obj : structToVisit.getMembers()) {
                    output.append(currentIndent.toString());
                    obj.accept(this);
                    if (obj.getKind() == Obj.Fld)
                    {
                        output.append("\n");
                    }
                }
                previousIndentationLevel();
                output.append(currentIndent.toString());
                output.append("]");
                break;
            }

        }

        public String getOutput() {
            StringBuilder tmp = output;
            output = new StringBuilder("");
            return tmp.toString();
        }

    }

    static class TabExt
    {
        static Struct boolType = new Struct(Struct.Bool);
        static SymbolTableVisitor symbolTableVisitor = new DumpUpgradeSymbolTableVisitor();
        static Obj programObj = null;
        static boolean doesMainExist = false;
        static int staticDataCnt = 0;
    }

    public static class ObjResultWrapper {
        Obj obj;
        boolean semanticError = false;
        boolean syntaxError = false;
        int relOp;

        public ObjResultWrapper() {}

        public ObjResultWrapper(Obj obj)
        {
            this.obj = obj;
        }

        public ObjResultWrapper clone()
        {
            ObjResultWrapper objWrapper = new ObjResultWrapper(obj);
            objWrapper.setSemanticError(semanticError);
            objWrapper.setSyntaxError(syntaxError);
            objWrapper.setRelOp(relOp);
            return objWrapper;
        }

        public void copyTo(ObjResultWrapper copyFrom)
        {
            setSemanticError(copyFrom.semanticError);
            setSyntaxError(copyFrom.syntaxError);
            setRelOp(copyFrom.relOp);
            obj = copyFrom.obj;
        }

        public Obj getObj() {
            return obj;
        }
        public void setObj(Obj obj) {
            this.obj = obj;
        }

        public boolean isSemanticError() {
            return semanticError;
        }

        public boolean isSyntaxError()
        {
            return syntaxError;
        }

        public ObjResultWrapper setSemanticError(boolean semanticError) {
            this.semanticError = semanticError;
            return this;
        }

        public ObjResultWrapper setSyntaxError(boolean syntaxError)
        {
            this.syntaxError = syntaxError;
            return this;
        }

        public void promoteToConst()
        {
            Struct objType = obj.getType();
            obj = new Obj(Obj.Con, "", objType);
        }

        public boolean isError()
        {
            return (syntaxError || semanticError);
        }

        public boolean isVar()
        {
            return (obj.getKind() == Obj.Var) || (obj.getKind() == Obj.Con)
                || (obj.getKind() == Obj.Fld) || (obj.getKind() == Obj.Elem);
        }

        public boolean isLeftValue()
        {
            return (isVar() && (obj.getKind() != obj.Con));
        }

        public boolean  isField()
        {
            return obj.getKind() == Obj.Fld;
        }

        public boolean isClassType()
        {
            return (obj.getKind() == Obj.Type) && (obj.getType().getKind() == Struct.Class);
        }

        public boolean isArrayElement()
        {
            return obj.getKind() == Obj.Elem;
        }

        public boolean isArray()
        {
            return (obj.getType().getKind() == Struct.Array)
                    && isLeftValue();
        }

        public boolean isClass()
        {
            return isLeftValue() && (obj.getType().getKind() == Struct.Class);
        }


        public boolean hasAdditionalParsOnStack()
        {
            return isArrayElement() || isField();
        }

        public boolean loadable()
        {
            int kind = obj.getKind();
            return isVar();
        }

        public void generateRightValue()
        {
            generateRightValue(true);
        }

        public void generateRightValue(boolean shouldPromote)
        {
            if (isArrayElement())
            {
                // a i a[i]
                Code.put(Code.dup_x2);
                // a[i] a i a[i]
                Code.put(Code.pop);
                // a[i] a i
                Code.put(Code.pop);
                // a[i] a
                Code.put(Code.pop);
                // a[i]

            }
            else if (isField())
            {
                // x x.i
                Code.put(Code.dup_x1);
                // x.i x x.i
                Code.put(Code.pop);
                // x.i x
                Code.put(Code.pop);
                // x.i
            }
            if (shouldPromote && isVar() && (obj.getType().getKind() != Struct.Array) && (obj.getType().getKind() != Struct.Class))
            {
                promoteToConst();
            }
        }

        public void setRelOp(int relOp)
        {
            this.relOp = relOp;
        }

        public int getRelOp()
        {
            return relOp;
        }

        ObjResultWrapper propagateError(ObjResultWrapper obj)
        {
            if (obj != null)
            {
                semanticError = semanticError || obj.isSemanticError();
                syntaxError = syntaxError || obj.isSyntaxError();
            }
            return this;
        }
    }


    // U slucaju greske.
    //
     @Override
    protected int error_sync_size() {
        // TODO Auto-generated method stubTab
        return 1;
    }

    static class ParserCnt {
        // NIVO A
        static int globalVarDefCnt = 0;
        static int localVarDefMainCnt = 0;
        static int globalConstDefCnt = 0;
        static int globalArrayDeclCnt = 0;

        // NIVO B
        static int globalAndStaticMethodCnt = 0;
        static int blockCnt = 0;
        static int funcCallInMainCnt = 0;
        static int formArgFunCnt = 0;

        // NIVO C
        static int classCnt = 0;
        static int methodCnt = 0;
        static int fieldCnt = 0;
    }

    boolean errorDetected = false;
    boolean syntaxError = false;
    boolean semanticError = false;
    String fileName = "test/generator/program.obj";


    public void setFileName(String fileName){
        this.fileName = fileName;
    }

    Logger log = Logger.getLogger(getClass());

    // MJParser greska.
    //
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    // Overrideovana MJParser funkcija.
    //
    public void syntax_error(Symbol cur_token) {
        syntaxError = true;
        report_error("\nSintaksna greska", cur_token);
    }

    public void semantic_error(String msg, Symbol sym)
    {
        semanticError = true;
        report_error("\nSemnaticka greska : " + msg, sym);
    }

    public void semantic_error(String msg)
    {
        semantic_error(msg, null);
    }

    public void semantic_error(String msg, int line)
    {
        semantic_error(msg + ". Linija:" + line + ".");
    }

    // Overrideovana MJParser funkcija.
    //
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    // Sa vezbi funkcija.
    //
    public void report_error(String message, Object info) {
        errorDetected = true;
        StringBuilder msg = new StringBuilder(message);
        if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
        StringBuilder msg = new StringBuilder(message);
        if (info instanceof Symbol)
        {
            Symbol symbol = (Symbol)info;
            msg.append(symbol.toString()).append (" na liniji ").append(symbol.left);
        }
        log.info(msg.toString());
    }

    public void report_info(String message)
    {
        report_info(message, null);
    }

    public boolean typesEqual(Struct type1, Struct type2)
    {
        // This is the same as check with name, because all types are on first level.
        //
        if (type1 == type2)
        {
            return true;
        }

        if ((type1.getKind() == Struct.Array)
            && (type2.getKind() == Struct.Array)
            && typesEqual(type1.getElemType(), type2.getElemType()))
            {
                return true;
            }
        return false;
    }

    public boolean typesCompatibile(Struct type1, Struct type2)
    {
        if (typesEqual(type1, type2)
        || (type1.isRefType() && (type2 == Tab.nullType) )
        || (type2.isRefType() && (type1 == Tab.nullType)) )
        {
            return true;
        }
        return false;
    }

    public Struct getParentClass(Struct childClass)
    {
        return childClass.getElemType();
    }

    boolean isDerivedClass(Struct childClass, Struct parentClass)
    {
        Struct curClass = null;
        while ( (curClass = getParentClass(childClass)) != null)
        {
            if (typesEqual(curClass, parentClass))
            {
                return true;
            }
            childClass = curClass;
        }
        return false;
    }

    public boolean typesAssignable(Struct dest, Struct expr)
    {
        if (typesEqual(dest, expr)
            || (dest.isRefType() && expr == Tab.nullType)
            || isDerivedClass(expr, dest))
            {
                return true;
            }
        return false;
    }

    boolean find_double_and_report_search(String name, int line, String additionalMessage)
    {
        Scope currentScope = Tab.currentScope;

        Obj objDoubleDef = currentScope.findSymbol(name);
        // Nadjen je duplikat u okruzujucem opsegu.
        //
        if (objDoubleDef != null)
        {
            additionalMessage += " simbol " + name +  " vec postoji.";
            semantic_error(additionalMessage, line);
            return true;
        }
        else
        {
            return false;
        }
    }

    ObjResultWrapper find_virtual_method(Struct childClass, String methodName,
    boolean isStatic, int line)
    {
        Struct parentClass = getParentClass(childClass);
        // If there is not method in symbol table for child class that means
        // it is not defined in non of its parent classes.
        //
        Obj methodObj  = childClass.getMembersTable().searchKey(methodName);
        if (methodObj == null)
        {
            return null;
        }

        // Method is either static or virtual or double.
        //

        Obj parentMethodObj = null;
        if (null != parentClass)
        {
            parentMethodObj  = parentClass.getMembersTable().searchKey(methodName);
        }
        // Method is double because it does not exsit in parent class.
        //
        if (parentMethodObj == null)
        {
            semantic_error("Metoda sa datim imenom vec postoji", line);
            return (new ObjResultWrapper()).setSemanticError(true);
        }

        // Method is either virtual or static, static ones cannot be overidden.
        if (parentMethodObj.getKind() != Obj.Meth)
        {
            semantic_error("Pokusavas da override-ujes nesto stoj nije metoda", line);
            return (new ObjResultWrapper()).setSemanticError(true);
        }

        if (isMethodStatic(parentMethodObj))
        {
            semantic_error("Pokusavas da override-ujes staticku metodu.", line);
            return (new ObjResultWrapper()).setSemanticError(true);
        }

        if (isStatic)
        {
            semantic_error("Staticka metoda ne moze da override-uje virtuelnu.", line);
            return (new ObjResultWrapper()).setSemanticError(true);
        }

        if (doesMethodOverride(methodObj))
        {
            semantic_error("Virtuelna metoda sa ovim imenom vec postoji", line);
            return (new ObjResultWrapper()).setSemanticError(true);
        }


        return new ObjResultWrapper(methodObj);
    }



    boolean check_type_and_report(Obj obj, Struct type, int line, String additionalMessage)
    {
        if (additionalMessage == null)
        {
            additionalMessage = "";
        }
        if (!typesEqual(obj.getType(), type)) {
            semantic_error(additionalMessage + ". Tipovi nisu isti. ", line);
            return false;
        }
        return true;
    }

    boolean check_type_and_report(Obj obj, LinkedList<Struct> listType, int line, String additionalMessage)
    {
        if (additionalMessage == "")
        {
            additionalMessage = "";
        }

        boolean found = false;

        for (Struct type : listType)
        {
            if (typesEqual(obj.getType(), type))
            {
                found = true;
                break;
            }
        }

        if (!found)
        {
            semantic_error(additionalMessage + "." + obj.getName() + " ne slaze se ni sa jednim od tipova.", line);
            return false;
        }
        return true;
    }

    boolean check_obj_kind_and_report(Obj obj, int kind, int line, String additionalMessage)
    {
        if (additionalMessage == null)
        {
            additionalMessage = "";
        }

        if (obj.getKind() != kind){
            semantic_error(additionalMessage + ". Nije odgovarajuce vrste.", line);
            return false;
        }
        return true;
    }

    public void detectSymbolInfo(Obj obj, int line)
    {
        TabExt.symbolTableVisitor.visitObjNode(obj);
        report_info("Detektovano koriscenje simbola:" + TabExt.symbolTableVisitor.getOutput());
        report_info("Linija:" + line);
        switch (obj.getKind())
        {
            case Obj.Con:
                report_info("Simbol je konstanta");
                break;
            case Obj.Var:
                if (obj.getLevel() == 0)
                {
                    report_info("Simbol je globalna promenljiva");
                }
                else
                {
                    if (obj.getFpPos() != 0)
                    {
                        report_info("Simbol je formalni parametar funkcije");
                    }
                    else
                    {
                        report_info("Simbol je lokalna promenljiva funkcije");
                    }
                }
                break;
            case Obj.Meth:
                if (isMethodGlobal(obj))
                {
                    report_info("Simbol je globalna funkcija");
                }
                else
                if (isMethodStatic(obj) || isMethodVirtual(obj))
                {
                    report_info("Simbol je metoda unutrasnje klase");
                }
                break;
            case Obj.Fld:
                report_info("Simbol je polje klase");
                break;
            case Obj.Type:
                report_info("Simbol je klasa");
                break;
            case Obj.Elem:
                report_info("Simbol je element niza");
                break;

        }
    }

    ObjResultWrapper find_for_use_and_report(String name, int line, String additionalMessage)
    {
        ObjResultWrapper result = null;
        Obj obj = Tab.find(name);
        result = new ObjResultWrapper(obj);
        if (obj == Tab.noObj)
        {
            semantic_error(additionalMessage + " Nije definisan u okruzujucem opsegu.", line);
            result.setSemanticError(true);
        }
        else
        {
            detectSymbolInfo(obj, line);
        }

        return result;
    }

    void pushOnCodeStack(LinkedList<LinkedList<Byte>> codeStack, int beginAddress)
    {
        // Oprezno, mozda je jos neophodno azurirati!!!
        //
        LinkedList<Byte> listOfCode = new LinkedList<Byte>();

        for (int idx = beginAddress; idx < Code.pc; idx ++)
        {
            listOfCode.addLast(Code.buf[idx]);
        }
        codeStack.addLast(listOfCode);
        Code.pc = beginAddress;
    }

    void popFromCodeStack(LinkedList<LinkedList<Byte>> codeStack)
    {
        LinkedList<Byte> listOfCode = codeStack.removeLast();
        for (int idx = 0; idx < listOfCode.size(); idx ++)
        {
            Code.put(listOfCode.get(idx));
        }
    }

    void updateAdresses(LinkedList<LinkedList<Integer>> list)
    {
        LinkedList<Integer> listOfJumpAdresses = list.removeLast();

        for (int idx = 0; idx < listOfJumpAdresses.size(); idx ++)
        {
            Code.fixup(listOfJumpAdresses.get(idx));
        }
    }

    public static int BIT_IS_STATIC = 0x1 << 1;
    public static int BIT_DOES_OVERRIDE = 0x1 << 2;
    public static int BIT_IS_GLOBAL = 0x1 << 3;
    public static int BIT_IS_VIRTUAL = 0x1 << 4;

    void putIntInStaticData(int val)
    {
        Code.loadConst(val);
        Code.put(Code.putstatic);
        Code.put2(TabExt.staticDataCnt++);
    }

    static void setBitOnInFpPos(Obj obj, int bit)
    {
        obj.setFpPos(obj.getFpPos() | bit);
    }

    static void setBitOffInFpPos(Obj obj, int bit)
    {
        obj.setFpPos(obj.getFpPos() & ~bit);
    }

    static boolean isBitOnInFpPos(Obj obj, int bit)
    {
        if ( (obj.getFpPos() & bit) != 0)
        {
            return true;
        }
        return false;
    }

    static void setMethodStatic(Obj obj)
    {
        setBitOnInFpPos(obj, BIT_IS_STATIC);
    }

    static boolean isMethodStatic(Obj obj)
    {
        return isBitOnInFpPos(obj, BIT_IS_STATIC);
    }

    static void setMethodOverride(Obj obj)
    {
        setBitOnInFpPos(obj, BIT_DOES_OVERRIDE);
    }

    static void setMethodOverride(Obj obj, boolean doesOveride)
    {
        if (doesOveride)
        {
            setBitOnInFpPos(obj, BIT_DOES_OVERRIDE);
        }
        else
        {
            setBitOffInFpPos(obj, BIT_DOES_OVERRIDE);
        }
    }

    static boolean doesMethodOverride(Obj obj)
    {
        return isBitOnInFpPos(obj, BIT_DOES_OVERRIDE);
    }

    static void setMethodVirtual(Obj obj)
    {
        setBitOnInFpPos(obj, BIT_IS_VIRTUAL);
    }

    static boolean isMethodVirtual(Obj obj)
    {
        return isBitOnInFpPos(obj, BIT_IS_VIRTUAL);
    }

    static void setMethodGlobal(Obj obj)
    {
        setBitOnInFpPos(obj, BIT_IS_GLOBAL);
    }

    static boolean isMethodGlobal(Obj obj)
    {
        return isBitOnInFpPos(obj, BIT_IS_GLOBAL);
    }

    static void incLastPar(LinkedList<Integer> list)
    {
        list.addLast(list.removeLast() + 1);
    }

    static void setParentClass(Obj child, Obj parent)
    {
        child.getType().setElementType(parent.getType());
    }

    static int countFormPars(Obj methodObj)
    {
        int cntArgs = 0;
        for (Obj o : methodObj.getLocalSymbols())
        {
            if (o.getFpPos() != 0)
            {
                cntArgs ++;
            }
        }
        return cntArgs;
    }

    static Obj getFormPar(Obj methObj, int formParIdx)
    {
        for (Obj o : methObj.getLocalSymbols())
        {
            if (o.getFpPos() == formParIdx)
            {
                return o;
            }
        }
        return null;
    }

    void initVirtualFunctionTable(Obj objType, LinkedList<Integer> listVFTAdresses)
    {
        Struct type = objType.getType();
        Collection<Obj> symbols = type.getMembers();
        if (listVFTAdresses.size() > 0)
        {
            Code.fixup(listVFTAdresses.getLast());
        }

        objType.setAdr(TabExt.staticDataCnt);
        for (Obj obj : symbols)
        {
            if ( (obj.getKind() == Obj.Meth) && !isMethodStatic(obj))
            {
                String name = obj.getName();
                for (int idx = 0; idx < name.length(); idx ++)
                {
                    putIntInStaticData((int)name.charAt(idx));
                }
                putIntInStaticData(-1);
                putIntInStaticData(obj.getAdr());
            }
        }
        putIntInStaticData(-2);

        Code.putJump(0);
        listVFTAdresses.addLast(Code.pc - 2);
    }

    public void copyFieldsAndMethodsFromParent(Obj parentClass, Obj childClass)
    {
        Struct parentType = parentClass.getType();
        Struct childType = childClass.getType();
        Collection<Obj> parentMembers = parentType.getMembers();

        for (Obj it : parentMembers)
        {
            if (it.getKind() == Obj.Fld)
            {
                Tab.insert(it.getKind(), it.getName(), it.getType());
            }
            else if (it.getKind() == Obj.Meth)
            {
                Obj methObj = Tab.insert(it.getKind(), it.getName(), it.getType());
                methObj.setAdr(it.getAdr());
                methObj.setFpPos(it.getFpPos());
                setMethodOverride(methObj, false);

                Tab.openScope();
                for (Obj itPars : it.getLocalSymbols())
                {
                    Obj objPar = null;
                    if (itPars.getName().equals("this"))
                    {
                        objPar = Tab.insert(itPars.getKind(), itPars.getName(), childType);
                    }
                    else
                    {
                        objPar = Tab.insert(itPars.getKind(), itPars.getName(), itPars.getType());
                    }
                    objPar.setFpPos(itPars.getFpPos());
                }
                Tab.chainLocalSymbols(methObj);
                Tab.closeScope();
            }
        }

    }

    public void extendFromParentClass(Obj childClass, Obj parentClass)
    {
        setParentClass(childClass, parentClass);
        copyFieldsAndMethodsFromParent(parentClass, childClass);
    }

:}

action code {:
    final String METHOD_ENTRY_NAME = "main";
    final String VFT_POINTER_NAME = "_vftPointer";
    final int OP_ASSIGN_CODE = 0;
    final int CHAR_SIZE = 1;
    final int INT_SIZE = 4;
    ObjResultWrapper curConstType = null;
    ObjResultWrapper curVarType = null ;
    ObjResultWrapper curLocalType = null;
    ObjResultWrapper curFormType = null;
    ObjResultWrapper curFieldType = null;
    ObjResultWrapper curObjWrappFieldOrElem = null;
    ObjResultWrapper curObjWrapperClass = null;
    ObjResultWrapper curObjWrapperMethod = null;
    LinkedList<ObjResultWrapper> listCurObjWrapperFieldOrElem = new LinkedList<ObjResultWrapper>();
    LinkedList<Integer> listAdrIfConditionTrue = new LinkedList<Integer>();
    LinkedList<Integer> listAdrIfConditionFalse = new LinkedList<Integer>();

    LinkedList<Integer> listAdrForConditionFalse  = new LinkedList<Integer>();
    LinkedList<Integer> listAdrForCondition = new LinkedList<Integer>();
    LinkedList<LinkedList<Byte>> listSavedCode = new LinkedList<LinkedList<Byte>>();
    LinkedList<LinkedList<Integer>> listOfListOfBreaksInFor = new LinkedList<LinkedList<Integer>>();
    LinkedList<LinkedList<Integer>> listOfListOfContinuesInFor = new LinkedList<LinkedList<Integer>>();
    LinkedList<Integer> listVFTAdresses = new LinkedList<Integer>();
    Integer forLastDesigantorBeginAddress = null;
    LinkedList<ObjResultWrapper> listCurObjWrapperFuncCall = new LinkedList<ObjResultWrapper>();
    LinkedList<Integer> listActParCnt = new LinkedList<>();
    boolean globalVar = false;
    boolean localVar = false;
    boolean formVar = false;
    boolean fieldVar = false;
    boolean isInClass = false;
    boolean addThis = false;
    Obj lenObj = null;
:}

scan with {:
    Symbol s = this.getScanner().next_token();
    if (s != null && s.value != null)
        log.debug(s.toString() + " " + s.value.toString());
    return s;
:}


init with {:
    Tab.init(); // Universe scope
:}


terminal PROGRAM, STATIC, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, FOR, EXTENDS, CONTINUE;
terminal String IDENT;
terminal Integer CONST_NUM;
terminal String CONST_CHAR;
terminal String CONST_BOOL;
terminal OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_MOD, OP_EQ, OP_NOT_EQ, OP_GREAT, OP_LESS, OP_GTE, OP_LTE;
terminal OP_AND, OP_OR, OP_ASSIGN, OP_ASSIGN_ADD, OP_ASSIGN_SUB, OP_ASSIGN_MUL, OP_ASSIGN_DIV, OP_ASSIGN_MOD;
terminal OP_INC, OP_DEC, SEMI_COLUMN, COMMA, DOT, PAR_LEFT, PAR_RIGHT;
terminal BRACKET_LEFT, BRACKET_RIGHT, BRACE_LEFT, BRACE_RIGHT;

non terminal Program;
non terminal GlobalDeclListEpsilon, GlobalDeclList, GlobalDecl, GlobalVarDecl, MethodDeclListEpsilon, MethodDeclList;
non terminal ConstDecl, ConstExprList, ConstExpr;
non terminal Obj ConstNum;
non terminal Obj ConstChar;
non terminal Obj ConstBool;
non terminal Obj ConstValue;
non terminal ObjResultWrapper VarExpr;
non terminal GlobalVarExprList, GlobalVarExprCommaList;
non terminal ObjResultWrapper VarExprOrErrorSemi;
non terminal ObjResultWrapper VarExprOrErrorComma;
non terminal Boolean BracketEpsilon;
non terminal ObjResultWrapper ExtendsTypeEpsilonBraceLeftOrError;
non terminal ClassDecl, FieldDeclList, FieldDecl, FieldExprList;
non terminal  FieldDeclListEpsilonBraceMethodDeclListEpsilon;
non terminal FieldDeclListOrErrorBraceLeft, FieldDeclErrorBraceLeft;
non terminal MethodDecl;
non terminal Boolean StaticEpsilon;
non terminal  ObjResultWrapper ReturnType;
non terminal  LocalVarDeclListBraceLeftEpsilon, LocalVarDeclListBraceLeft, LocalVarDeclOrErrorSemi, LocalVarDeclListOrErrorSemi, LocalVarExprList, LocalVarDeclOrErrorBraceLeft, StatementListEpsilon, StatementList;
non terminal FormPars, FormPar, FormParsEpsilonParRight, FormParOrErrorComma, FormParsParRight, FormParOrErrorParRight;
non terminal ObjResultWrapper Type;
non terminal Statement, ElseStatementEpsilon, IfConditionParRight;
non terminal ObjResultWrapper ExprEpsilon;
non terminal Obj CommaConstNumEpsilon;
non terminal DesignatorStatement;
non terminal ObjResultWrapper ActParsEpsilon;
non terminal ObjResultWrapper ActPars;
non terminal ObjResultWrapper CommaExprListEpsilon;
non terminal ObjResultWrapper CommaExprList;
non terminal ObjResultWrapper CommaExpr;
non terminal DesignatorStatementOrAssignErrorSemi, DesignatorStatementOrAssignOrErrorParRight, AssingmentStatement, DesignatorStatementOrAssign, AssingmentStatementOrErrorSemi;
non terminal ObjResultWrapper ForConditionSemi;
non terminal ObjResultWrapper DesignatorIncOrDec;
non terminal ObjResultWrapper DesignatorFuncCall;
non terminal Integer IncOrDec;
non terminal ObjResultWrapper ExpOrErrorSemi;
non terminal ObjResultWrapper ForCondition;
non terminal ObjResultWrapper OpOrCondTermList;
non terminal ObjResultWrapper OpAndCondFactList;
non terminal ObjResultWrapper CondFact;
non terminal ObjResultWrapper RelOpExprOrEpsilon;
non terminal ObjResultWrapper Expr;
non terminal ObjResultWrapper AddopRightTerm;
non terminal ObjResultWrapper AddopLeftTerm;
non terminal ObjResultWrapper Term;
non terminal ObjResultWrapper MullopRightFactor;
non terminal ObjResultWrapper  MulopLeftFactor;
non terminal ObjResultWrapper Factor;
non terminal ObjResultWrapper BracketExprEpsilon;
non terminal ObjResultWrapper Designator;
non terminal ObjResultWrapper DotIdentOrBracketExprListEpsilon;
non terminal ObjResultWrapper DotIdentOrBracketExprList;
non terminal ObjResultWrapper DotIdentOrBracketExpr;
non terminal Integer Assignop;
non terminal Integer Relop;
non terminal Integer AddopLeft;
non terminal Integer AddopRight;
non terminal Integer MulopLeft;
non terminal Integer MulopRight;


precedence left ELSE;

/************************* PROGRAM **************************/
/************************************************************/
Program ::=
    {:
        parser.report_info("Krece da prepoznaje globalne deklaracije", null);
    :}
    PROGRAM
    IDENT : programName
    {:

        Tab.insert(Obj.Type, "bool", TabExt.boolType);

        Obj eolObj = Tab.find("eol");
        eolObj.setAdr((int)'\n');

        Obj chrObj = Tab.find("chr");
        Obj chrPar = chrObj.getLocalSymbols().iterator().next();
        chrPar.setFpPos(1);
        chrObj.setAdr(Code.pc);
        Code.put(Code.enter);
        Code.put(1);
        Code.put(1);
        // Read variable from procedure stack and leave it as return value.
        Code.put(Code.load_n);
        Code.put(Code.exit);
        Code.put(Code.return_);

        Obj ordObj = Tab.find("ord");
        Obj ordPar = ordObj.getLocalSymbols().iterator().next();
        ordPar.setFpPos(1);
        ordObj.setAdr(Code.pc);
        Code.put(Code.enter);
        Code.put(1);
        Code.put(1);
        Code.put(Code.load_n);
        Code.put(Code.exit);
        Code.put(Code.return_);

        lenObj = Tab.find("len");
        Obj lenPar = lenObj.getLocalSymbols().iterator().next();
        lenPar.setFpPos(1);
        lenObj.setAdr(Code.pc);
        Code.put(Code.enter);
        Code.put(1);
        Code.put(1);
        Code.put(Code.load_n);
        Code.put(Code.arraylength);
        Code.put(Code.exit);
        Code.put(Code.return_);


        TabExt.programObj = Tab.insert(Obj.Prog, programName, Tab.noType);

        Tab.openScope();
    :}
    GlobalDeclListEpsilon
    BRACE_LEFT
    MethodDeclListEpsilon
    BRACE_RIGHT
    {:

        // TODO update with virtual table.
        //
        Code.dataSize = TabExt.staticDataCnt;
        Tab.chainLocalSymbols(TabExt.programObj);
        Tab.closeScope();

        if (!TabExt.doesMainExist)
        {
            semantic_error("Ne postoji globalna main funkcija");
        }

        parser.report_info("****************** NIVO A***********************", null);
        parser.report_info("Broj definicija globalnih promenljivih " + ParserCnt.globalVarDefCnt, null);
        parser.report_info("Broj definicija lokalnih promenljivih u main funkciji " + ParserCnt.localVarDefMainCnt, null);
        parser.report_info("Broj definicija globalnih konstanti " + ParserCnt.globalConstDefCnt, null);
        parser.report_info("Broj deklaracija globalnih nizova " + ParserCnt.globalArrayDeclCnt, null);

        parser.report_info("******************* NIVO B**********************", null);
        parser.report_info("Broj definicija globalnih i statickih funkcija unutrasnjih klasa " + ParserCnt.globalAndStaticMethodCnt, null);
        parser.report_info("Broj blokova naredbi " + ParserCnt.blockCnt, null);
        parser.report_info("Broj poziva funkcija u telu main methode " + ParserCnt.funcCallInMainCnt, null);
        parser.report_info("Broj deklaracija formalnih argumenata funkcija " + ParserCnt.formArgFunCnt, null);

        parser.report_info("******************* NIVO C**********************", null);
        parser.report_info("Broj definicija unutrasnjih klasa " + ParserCnt.classCnt, null);
        parser.report_info("Broj definicija metoda unutrasnjih klasa " + ParserCnt.methodCnt, null);
        parser.report_info("Broj deklaracije polja unutrasnjih klasa " + ParserCnt.fieldCnt, null);

        parser.report_info("USPESNO PREPOZNAVANJE", null);
        Tab.dump(TabExt.symbolTableVisitor);

        if (errorDetected)  {
            parser.report_error("Neuspesno parsiranje!!!", null);
        }
        else {
            parser.report_info("Uspesno parsiranje!!!", null);
            File f = new File(fileName);
            if (f.exists())
            {
                f.delete();
            }
            f = new File(fileName);
            Code.write(new FileOutputStream(f));

        }
    :}
    ;

GlobalDeclListEpsilon ::=
    GlobalDeclList
    |
    /* epsilon */
    ;

GlobalDeclList ::=
    GlobalDeclList GlobalDecl
    |
    GlobalDecl
    ;

GlobalDecl ::=
    ConstDecl
    |
    // Samo zbog oporavka od greske.
    //
    GlobalVarDecl
    |
    ClassDecl
    {:
        parser.log.debug("Prepoznata klasa", null);
    :}
    ;


GlobalVarDecl ::=
    Type:varType
    {:
        curVarType = varType;
        globalVar = true;
    :}
    GlobalVarExprList
    {:
        globalVar = false;
    :}
    ;
GlobalVarExprList ::=
    GlobalVarExprCommaList VarExprOrErrorSemi
    |
    VarExprOrErrorSemi:exprOrError
    {:
        RESULT = exprOrError;
    :}
    ;

VarExprOrErrorSemi ::=
    VarExpr:t
    SEMI_COLUMN
    {:
        RESULT = (new ObjResultWrapper());
    :}
    |
    error:text SEMI_COLUMN
    {:
        RESULT = (new ObjResultWrapper()).setSyntaxError(true);

        parser.report_error("Uspesan oporavak od greske deklaracije globalne promenljive,  SEMI_COLUMN je resio stvar" , null);
    :}
    ;

GlobalVarExprCommaList ::=
    GlobalVarExprCommaList VarExprOrErrorComma
    |
    VarExprOrErrorComma:exprOrError
    {:
        RESULT = exprOrError;
    :}
    ;
VarExprOrErrorComma ::=
    VarExpr:t
    COMMA
    {:
        RESULT  = t;
    :}
    |
    error COMMA
    {:
        RESULT = (new ObjResultWrapper()).setSyntaxError(true);
        parser.report_error("Uspesan oporavak od greske prilikom deklaracije globalne promenljiva COMMA je resila stvar", null);
    :}
    ;



MethodDeclListEpsilon ::=
    MethodDeclList
    |
    /* epsilon */
    ;

MethodDeclList ::=
    MethodDeclList MethodDecl
    |
    MethodDecl
    ;

/************************* ConstDecl ************************/
/************************************************************/
ConstDecl ::=
    CONST Type:type
    {:
        curConstType = type;
    :}
    ConstExprList
    {:

    :}SEMI_COLUMN
    ;

ConstExprList ::=
    ConstExprList COMMA ConstExpr
    |
    ConstExpr
    ;

ConstExpr ::=
    IDENT:nameOfConst OP_ASSIGN ConstValue:numObj
    {:
        // Da li se konstanta slaze po tipu sa deklaracijom.
        //
        if (!curConstType.isSemanticError()
            &&(check_type_and_report(numObj, curConstType.getObj().getType(), numObj.getLevel(), " poredjenje tipova konstanti")))
        {
            // Da nema slucajno duplikata.
            //
            if (!find_double_and_report_search(nameOfConst, nameOfConstleft, "Konstanta"))
            {
                Obj constObj = Tab.insert(Obj.Con, nameOfConst, curConstType.getObj().getType());
                constObj.setAdr(numObj.getAdr());
                ParserCnt.globalConstDefCnt++;
            }

        }

    :}
    ;

ConstValue ::=
        ConstNum:constNum
        {:
            RESULT = constNum;
        :}
        |
        ConstBool:constBool
        {:
            RESULT = constBool;
        :}
        |
        ConstChar:constChar
        {:
            RESULT = constChar;
        :}
        ;

ConstNum ::=
        CONST_NUM:number
        {:
            RESULT = new Obj(Obj.Con, number.toString(), Tab.intType, number.intValue(), numberleft);
        :}
        ;

ConstBool ::=
        CONST_BOOL:boolStr
        {:
            RESULT = new Obj(Obj.Con, "", TabExt.boolType, Boolean.valueOf(boolStr) ? 1 : 0, boolStrleft);
        :}
        ;

ConstChar ::=
        CONST_CHAR : charStr
        {:
            char c = charStr.charAt(1);
            if (c== '\\')
            {
                c = charStr.charAt(2);
                switch (c)
                {
                case 'n':
                    c = '\n';
                    break;
                case 'r':
                    c='\r';
                    break;
                case 't':
                    c='\t';
                    break;
                case 'b':
                    c='\b';
                    break;
                }
            }
            RESULT = new Obj(Obj.Con, "", Tab.charType,
            c, charStrleft);

        :}
        ;

/************************* VarDecl **************************/
/************************************************************/
VarExpr ::=
    IDENT:nameOfVar
    BracketEpsilon:isArray
    {:
        {
            Struct typeVar = null;
            String message = "";
            Obj varObj = null;
            int objType = Obj.Var;

            if (globalVar)
            {
                message = "Definicija globalne varijable";
                if (!curVarType.isSemanticError())
                {
                    typeVar = curVarType.getObj().getType();
                }
                ParserCnt.globalVarDefCnt++;
                if (isArray)
                {
                    ParserCnt.globalArrayDeclCnt++;
                }
            }
            else if (localVar)
            {
                message = "Definicija lokalne varijable";
                if (!curLocalType.isSemanticError())
                {
                    typeVar = curLocalType.getObj().getType();
                }
                if (!isInClass && curObjWrapperMethod.getObj().getName().equals(METHOD_ENTRY_NAME))
                {
                    ParserCnt.localVarDefMainCnt++;
                }
            }
            else if (formVar)
            {
                ParserCnt.formArgFunCnt++;
                message = "Definicija formalnog parametra";
                if (!curFormType.isSemanticError())
                {
                    typeVar = curFormType.getObj().getType();
                }
            }
            else if (fieldVar)
            {
                ParserCnt.fieldCnt++;
                message = "Definicija polja klase";
                if (!curFieldType.isSemanticError())
                {
                    typeVar = curFieldType.getObj().getType();
                    objType = Obj.Fld;
                }
            }

            if (isArray)
            {
                if (typeVar != null)
                {
                    typeVar = new Struct (Struct.Array, typeVar);
                }
            }
            if (!find_double_and_report_search(nameOfVar, nameOfVarleft, message)
                && (typeVar != null) )
            {
                varObj = Tab.insert(objType, nameOfVar, typeVar);
                if (formVar)
                {
                    varObj.setAdr(Tab.currentScope().getnVars() - 1);
                    varObj.setFpPos(Tab.currentScope().getnVars());
                }
                else if (globalVar)
                {
                    varObj.setAdr(TabExt.staticDataCnt++);
                }
            }
            else
            {
                RESULT = (new ObjResultWrapper()).setSemanticError(true);
            }
        }

    :}
    ;

BracketEpsilon ::=
    BRACKET_LEFT
    BRACKET_RIGHT
    {:
        RESULT = true;
    :}
    |
    {:
        RESULT = false;
    :}
    ;


/************************* ClassDecl **************************/
/************************************************************/
ClassDecl ::=
    CLASS
    IDENT:nameOfClass
    {:
        ParserCnt.classCnt++;
        isInClass = true;
        if (find_double_and_report_search(nameOfClass, nameOfClassleft, "Ime je vec deklarisano u okruzujucem opsegu"))
        {
            // TODO : test
            curObjWrapperClass = (new ObjResultWrapper()).setSemanticError(true);
            curObjWrapperClass.setSemanticError(true);
        }
        else
        {
            Obj obj = Tab.insert(Obj.Type, nameOfClass, new Struct(Struct.Class));
            curObjWrapperClass = new ObjResultWrapper(obj);
        }
    :}
    ExtendsTypeEpsilonBraceLeftOrError:extendsType
    {:
        if (!curObjWrapperClass.isSemanticError())
        {
            Tab.openScope();
            if ( (extendsType != null) && (!extendsType.isError()))
            {
                extendFromParentClass( curObjWrapperClass.getObj(), extendsType.getObj());
            }
            else
            {
                Tab.insert(Obj.Fld, VFT_POINTER_NAME, Tab.intType);
            }
        }
    :}

    FieldDeclListEpsilonBraceMethodDeclListEpsilon
    BRACE_RIGHT
    {:
        Tab.closeScope();
        Tab.insert(Obj.Type, curObjWrapperClass.getObj().getName(), curObjWrapperClass.getObj().getType());

        if (listVFTAdresses.size() == 0)
        {
            Code.mainPc = Code.pc;
        }
        initVirtualFunctionTable(curObjWrapperClass.getObj(), listVFTAdresses);

        isInClass = false;
        parser.log.debug("Prepoznata klasa", null);
    :}
    ;

ExtendsTypeEpsilonBraceLeftOrError ::=
    EXTENDS Type:type BRACE_LEFT
    {:
        if (!type.isError())
        {
            if ( (type.getObj().getKind() != Obj.Type) || (type.getObj().getType().getKind() != Struct.Class))
            {
                semantic_error("Tip " + type.getObj().getName() + " nije tipa klase.", typeleft);
                RESULT = type.setSemanticError(true);
            }
            else
            {
                RESULT = type;
            }
        }
        else
        {
            RESULT = type;
        }
    :}
    |
    EXTENDS error BRACE_LEFT
    {:
        parser.report_error("Uspesan oporavak od greske kod EXTEND-a,  BRACE_LEFT je resila stvar" , null);
        RESULT = (new ObjResultWrapper()).setSyntaxError(true);
    :}
    |
    {:
        RESULT = null;
    :}
    BRACE_LEFT
    ;

FieldDeclListEpsilonBraceMethodDeclListEpsilon ::=
    FieldDeclListOrErrorBraceLeft
    MethodDeclListEpsilon BRACE_RIGHT
    |
    FieldDeclList
    {:
        Tab.chainLocalSymbols(curObjWrapperClass.getObj().getType());
    :}
    |
    BRACE_LEFT
    {:
        Tab.chainLocalSymbols(curObjWrapperClass.getObj().getType());
    :}
    MethodDeclListEpsilon BRACE_RIGHT
    |
    {:
        Tab.chainLocalSymbols(curObjWrapperClass.getObj().getType());
    :}
    ;


FieldDeclListOrErrorBraceLeft ::=
    FieldDeclList
    {:
        Tab.chainLocalSymbols(curObjWrapperClass.getObj().getType());
    :}
    BRACE_LEFT
    |
    FieldDeclErrorBraceLeft
    |
    FieldDeclList FieldDeclErrorBraceLeft
    |
    FieldDeclList error
    {:
        parser.report_error("Uspesan oporavak od greske kod deklaracije fieldsa,  BRACE_LEFT je resio stvar" , null);
        Tab.chainLocalSymbols(curObjWrapperClass.getObj().getType());
    :}
    BRACE_LEFT
    |
    error
    {:
        parser.report_error("Uspesan oporavak od greske kod deklaracije fieldsa,  BRACE_LEFT je resio stvar" , null);
        Tab.chainLocalSymbols(curObjWrapperClass.getObj().getType());
    :}
    BRACE_LEFT
    ;

FieldDeclErrorBraceLeft ::=
    Type
    error
    {:
        parser.report_error("Uspesan oporavak od greske kod deklaracije fieldsa,  BRACE_LEFT je resio stvar" , null);
        Tab.chainLocalSymbols(curObjWrapperClass.getObj().getType());
    :}

    BRACE_LEFT
    ;

FieldDeclList ::=
            FieldDeclList FieldDecl
            |
            FieldDecl
            ;

FieldDecl ::=
    Type:type
    {:
        curFieldType = type;
        fieldVar = true;
    :}
    FieldExprList SEMI_COLUMN
    {:
        fieldVar = false;
    :}
    |
    Type:type error SEMI_COLUMN
    {:
       parser.report_error("Uspesan oporavak od greske kod deklaracije fieldsa,  SEMI_COLUMN je resio stvar" , null);
    :}
    |
    error SEMI_COLUMN
    {:
        parser.report_error("Uspesan oporavak od greske kod deklaracije fieldsa,  SEMI_COLUMN je resio stvar" , null);
    :}
    ;
FieldExprList ::=
            FieldExprList COMMA VarExpr
            |
            VarExpr
            ;

/************************* MethodDecl **************************/
/************************************************************/
MethodDecl ::=
        StaticEpsilon:isStatic
        ReturnType:retType
        {:
            parser.log.debug("Prepoznat povratni tip", null);
        :}
        IDENT:nameOfMethod
        {:

            String message = "Metoda";
            if (isInClass)
            {
                ParserCnt.methodCnt++;
                ObjResultWrapper objWrapper = find_virtual_method(curObjWrapperClass.getObj().getType(), nameOfMethod, isStatic, nameOfMethodleft);
                if (objWrapper == null)
                {
                    Obj curMethod  = Tab.insert(Obj.Meth, nameOfMethod, retType.getObj().getType());
                    curObjWrapperMethod = new ObjResultWrapper(curMethod);
                    if (isStatic)
                    {
                        ParserCnt.globalAndStaticMethodCnt++;
                        setMethodStatic(curObjWrapperMethod.getObj());
                    }
                    else
                    {
                        setMethodVirtual(curObjWrapperMethod.getObj());
                    }
                }
                else if (!objWrapper.isSemanticError())
                {
                    curObjWrapperMethod = objWrapper;
                    setMethodOverride(curObjWrapperMethod.getObj());
                }
                else
                {
                    curObjWrapperMethod.setSemanticError(true);
                }
            }
            else
            {
                if (!find_double_and_report_search(nameOfMethod, nameOfMethodleft, message))
                {
                    ParserCnt.globalAndStaticMethodCnt++;
                    if (isStatic)
                    {
                        semantic_error("STATIC ne moze da se koristi kod globalnih funkcija", isStaticleft);
                    }
                    Obj curMethod  = Tab.insert(Obj.Meth, nameOfMethod, retType.getObj().getType());
                    curObjWrapperMethod = new ObjResultWrapper(curMethod);
                    setMethodGlobal(curObjWrapperMethod.getObj());
                }
                else
                {
                    curObjWrapperMethod = (new ObjResultWrapper()).setSemanticError(true);
                }
            }
            curObjWrapperMethod.propagateError(retType);
        :}
        PAR_LEFT
        {:
            Tab.openScope();
            if (!curObjWrapperMethod.isError())
            {
                if (!isStatic && isInClass)
                {
                    Obj varObj = Tab.insert(Obj.Var, "this", curObjWrapperClass.getObj().getType());
                    varObj.setAdr(0);
                    varObj.setFpPos(1);
                    addThis = false;
                }
            }
        :}
        FormParsEpsilonParRight
        {:
            if (!curObjWrapperMethod.isError())
            {
                curObjWrapperMethod.getObj().setLevel(Tab.currentScope().getnVars());
            }
        :}
        LocalVarDeclListBraceLeftEpsilon
        {:
            if (!curObjWrapperMethod.isError())
            {
                if (!doesMethodOverride(curObjWrapperMethod.getObj()))
                {
                    Tab.chainLocalSymbols(curObjWrapperMethod.getObj());
                }
                curObjWrapperMethod.getObj().setAdr(Code.pc);
                if (nameOfMethod.equals(METHOD_ENTRY_NAME)
                    && !isInClass && (curObjWrapperMethod.getObj().getLevel() == 0))
                {
                    TabExt.doesMainExist = true;
                    if (listVFTAdresses.size() == 0)
                    {
                        Code.mainPc = curObjWrapperMethod.getObj().getAdr();
                    }
                    else
                    {
                        Code.fixup(listVFTAdresses.getLast());
                    }
                }

                Code.put(Code.enter);
                Code.put(curObjWrapperMethod.getObj().getLevel());
                Code.put(Tab.currentScope().getnVars());
            }

            parser.log.debug("Zavrseno prepoznavanje deklaracija lokalnih promen", null);
        :}
        StatementListEpsilon
        BRACE_RIGHT
        {:
            ParserCnt.blockCnt++;
            if (!retType.isError())
            {
                if (typesEqual(retType.getObj().getType(),Tab.noType))
                {
                    Code.put(Code.exit);
                    Code.put(Code.return_);
                }
                else
                {
                    // Error in case of no return.
                    //
                    Code.put(Code.trap);
                    Code.put(1);
                }
            }

            Tab.closeScope();
            parser.log.debug("Prepoznat METHOD", null);
        :}
        ;
StaticEpsilon ::=
            STATIC
            {:
                RESULT = new Boolean(true);
            :}

            |
            /*epsilon*/
            {:
                RESULT = new Boolean(false);
            :}
            ;
ReturnType ::=
            Type:type
            {:
                RESULT = type;
            :}
            |
            VOID
            {:
                RESULT = new ObjResultWrapper(new Obj(Obj.Type, "", Tab.noType));
            :}
            ;
FormParsEpsilonParRight ::=
            FormParsParRight
            |
            PAR_RIGHT
            ;
LocalVarDeclListBraceLeftEpsilon ::=
            LocalVarDeclListBraceLeft
            |
            BRACE_LEFT
            ;

LocalVarDeclListBraceLeft ::=
            LocalVarDeclListOrErrorSemi LocalVarDeclOrErrorBraceLeft
            |
            LocalVarDeclOrErrorBraceLeft
            ;

LocalVarDeclListOrErrorSemi ::=
            LocalVarDeclListOrErrorSemi LocalVarDeclOrErrorSemi
            |
            LocalVarDeclOrErrorSemi
            ;

LocalVarDeclOrErrorSemi ::=
            Type:type
            {:
                curLocalType =  type;
                localVar = true;
            :}
            LocalVarExprList SEMI_COLUMN
            {:
                localVar = false;
            :}
            |
            error:text SEMI_COLUMN
            {:
              parser.report_error("Uspesan oporavak od greske deklaracije lokalne promenljive,  SEMI_COLUMN je resio stvar" , null);
            :}
            ;
LocalVarExprList ::=
            LocalVarExprList COMMA VarExpr
            |
            VarExpr
            ;

LocalVarDeclOrErrorBraceLeft ::=
            error:text BRACE_LEFT
            {:
                  parser.report_error("Uspesan oporavak od greske deklaracije lokalne promenljive,  BRACE_LEFT je resila stvar" , null);
            :}
            |
            LocalVarDeclOrErrorSemi BRACE_LEFT
            ;

StatementListEpsilon ::=
            StatementList
            |
            /* epsilon */
            ;
StatementList ::=
            StatementList Statement
            |
            Statement
            ;

/************************* FormPars **************************/
/************************************************************/
FormParsParRight ::=
            FormPars FormParOrErrorParRight
            |
            FormParOrErrorParRight
            ;

FormPars ::=
            FormPars FormParOrErrorComma
            |
            FormParOrErrorComma
            ;

FormParOrErrorComma ::=
            FormPar COMMA
            |
            error COMMA
            {:
                  parser.report_error("Uspesan oporavak od greske deklaracije formalnog parametra lokalne funkcije,  COMMA je resila stvar" , null);
            :}
            ;

FormParOrErrorParRight ::=
            FormPar PAR_RIGHT
            |
            error PAR_RIGHT
            {:
                  parser.report_error("Uspesan oporavak od greske deklaracije formalnog parametra lokalne funkcije,  PAR_RIGHT je resio stvar" , null);
            :}
            ;

FormPar::=
            Type:type
            {:
                curFormType = type;
                formVar = true;
            :}
            VarExpr
            {:
                formVar = false;
            :}
            ;




/************************* Type **************************/
/************************************************************/
Type ::=
        IDENT:nameOfType
        {:
            Obj obj = Tab.find(nameOfType);
            if (obj.getKind() != Obj.Type)
            {
                obj = new Obj(Obj.Type, "", Tab.noType);
                semantic_error("Nije definisan tip:" + nameOfType+" ", nameOfTypeleft);
                RESULT = (new ObjResultWrapper()).setSemanticError(true);
            }
            else
            {
                RESULT = new ObjResultWrapper(obj);
            }
        :}
        ;


/************************* Statement **************************/
/************************************************************/

Statement ::=
    DesignatorStatementOrAssignErrorSemi:st
    {:
        parser.log.debug("Prepoznata STATEMENT", null);
    :}
    |
    // TODO : add check for type of expression.
    //
    IF PAR_LEFT IfConditionParRight
    {:
        // FALSE.
        //
        Code.put(Code.const_n);
        Code.putFalseJump(Code.ne, 0);
        int adrConditionFalse = Code.pc - 2;
        listAdrIfConditionFalse.addLast(adrConditionFalse);
    :}
    Statement
    {:

        Code.putJump(0);
        Code.fixup(listAdrIfConditionFalse.removeLast());
        int adrConditionTrue = Code.pc - 2;
        listAdrIfConditionTrue.addLast(adrConditionTrue);
    :}
    ElseStatementEpsilon
    {:

        Code.fixup(listAdrIfConditionTrue.removeLast());
        parser.log.debug("Prepoznat IF", null);
    :}

    |
    IF PAR_LEFT error
    {:
        parser.report_error("Uspesan oporavak od greske kod IF-a,  PAR_RIGHT je resila stvar" , null);
        // FALSE.
        //
        Code.put(Code.const_n);
        Code.putFalseJump(Code.ne, 0);
        int adrConditionFalse = Code.pc - 2;
        listAdrIfConditionFalse.addLast(adrConditionFalse);
    :}
    Statement
    {:

        Code.putJump(0);
        Code.fixup(listAdrIfConditionFalse.removeLast());
        int adrConditionTrue = Code.pc - 2;
        listAdrIfConditionTrue.addLast(adrConditionTrue);
    :}
    ElseStatementEpsilon
    {:

        Code.fixup(listAdrIfConditionTrue.removeLast());
        parser.log.debug("Prepoznat IF", null);
    :}

    |
    FOR PAR_LEFT DesignatorStatementOrAssign:assign SEMI_COLUMN
    {:
        listAdrForCondition.addLast(Code.pc);
    :}
    ForConditionSemi:forCondition
    {:
        if (!forCondition.isError())
        {
            if (check_type_and_report(forCondition.getObj(), TabExt.boolType, forConditionleft, "Tipa izraza uslovu for petlje."))
            {

            }
        }
        Code.put(Code.const_n);
        Code.putFalseJump(Code.ne, 0);
        int adrConditionFalse = Code.pc - 2;
        listAdrForConditionFalse.addLast(adrConditionFalse);

        forLastDesigantorBeginAddress = Code.pc;
    :}
    DesignatorStatementOrAssignOrErrorParRight
    {:
        pushOnCodeStack(listSavedCode, forLastDesigantorBeginAddress);
        listOfListOfContinuesInFor.addLast(new LinkedList<Integer>());
        listOfListOfBreaksInFor.addLast(new LinkedList<Integer>());
    :}

    Statement
    {:
        updateAdresses(listOfListOfContinuesInFor);
        popFromCodeStack(listSavedCode);

        int adrCondition = listAdrForCondition.removeLast();
        Code.putJump(adrCondition);

        updateAdresses(listOfListOfBreaksInFor);
        Code.fixup(listAdrForConditionFalse.removeLast());
    :}
    |
    FOR error SEMI_COLUMN ForCondition SEMI_COLUMN DesignatorStatementOrAssign PAR_RIGHT
    {:
        parser.report_error("Uspesan oporavak od greske kod FOR-a,  SEMI_COLUMN je resio stvar" , null);
    :}
    |
    FOR DesignatorStatementOrAssign SEMI_COLUMN error SEMI_COLUMN DesignatorStatementOrAssign PAR_RIGHT
    {:
        parser.report_error("Uspesan oporavak od greske kod FOR-a,  SEMI_COLUMN je resio stvar" , null);
    :}
    |
    FOR DesignatorStatementOrAssign SEMI_COLUMN ForCondition SEMI_COLUMN error PAR_RIGHT
    {:
        parser.report_error("Uspesan oporavak od greske kod FOR-a,  PAR_RIGHT je resio stvar" , null);
    :}
    |
    FOR error SEMI_COLUMN error SEMI_COLUMN DesignatorStatementOrAssign PAR_RIGHT
    {:
        parser.report_error("Uspesan oporavak od greske kod FOR-a,  SEMI_COLUMN je resio stvar" , null);
    :}
    |
    FOR error SEMI_COLUMN ForCondition SEMI_COLUMN error PAR_RIGHT
    {:
        parser.report_error("Uspesan oporavak od greske kod FOR-a,  PAR_RIGHT ili SEMI_COLUMN je resio stvar" , null);
    :}
    |
    FOR DesignatorStatementOrAssign SEMI_COLUMN error SEMI_COLUMN error PAR_RIGHT
    {:
        parser.report_error("Uspesan oporavak od greske kod FOR-a,  PAR_RIGHT ili SEMI_COLUMN je resio stvar" , null);
    :}
    |
    FOR error SEMI_COLUMN error SEMI_COLUMN error PAR_RIGHT
    {:
        parser.report_error("Uspesan oporavak od greske kod FOR-a,  PAR_RIGHT ili SEMI_COLUMN je resio stvar" , null);
    :}
    |
    FOR error SEMI_COLUMN error PAR_RIGHT
    {:
        parser.report_error("Uspesan oporavak od greske kod FOR-a,  PAR_RIGHT ili SEMI_COLUMN je resio stvar" , null);
    :}
    |
    FOR error PAR_RIGHT
    {:
        parser.report_error("Uspesan oporavak od greske kod FOR-a,  PAR_RIGHT je resio stvar" , null);
    :}
    |
    BREAK:breakObj SEMI_COLUMN
    {:
        if (!listAdrForCondition.isEmpty())
        {
            // Ne mora 0. Moze sta god.
            //
            Code.putJump(0);
            int adr = Code.pc - 2;
            listOfListOfBreaksInFor.getLast().addLast(adr);
            parser.log.debug("Prepoznat BREAK", null);
        }
        else
        {
            semantic_error("BREAK mora da ima okruzujuci FOR.", breakObjleft);
        }

    :}
    |
    CONTINUE:continueObj SEMI_COLUMN
    {:
        if (!listAdrForCondition.isEmpty())
        {
            Code.putJump(0);
            int adr = Code.pc - 2;
            listOfListOfContinuesInFor.getLast().addLast(adr);
            parser.log.debug("Prepoznat CONTINUE", null);
        }
        else
        {
            semantic_error("CONTINUE mora da ima okruzujuci FOR.", continueObjleft);
        }

    :}
    |
    RETURN:returnObj ExprEpsilon:retVal SEMI_COLUMN
    {:
        if (curObjWrapperMethod != null)
        {
            if (!curObjWrapperMethod.isError())
            {
                if (retVal == null)
                {
                    if (check_type_and_report(curObjWrapperMethod.getObj(), Tab.noType, retValleft, "RETURN mora da ima povratnu vrednost"))
                    {
                        Code.put(Code.exit);
                        Code.put(Code.return_);
                    }
                }
                else
                {
                    if (!retVal.isError())
                    {
                        if (check_type_and_report(curObjWrapperMethod.getObj(), retVal.getObj().getType(), retValleft, "RETURN vrednost mora da se slaze po tipu sa povratnom vrednoscu metode/funkcije"))
                        {
                            Code.put(Code.exit);
                            Code.put(Code.return_);
                        }
                    }
                }

            }
        }
        else
        {
            semantic_error("RETURN mora da bude unutar funkcije/metode", returnObjleft);
        }

        parser.log.debug("Prepoznat RETURN", null);
    :}
    |
    READ PAR_LEFT Designator:des PAR_RIGHT SEMI_COLUMN
    {:
        LinkedList<Struct> listType = new LinkedList<Struct>();
        listType.addLast(Tab.intType);
        listType.addLast(Tab.charType);
        listType.addLast(TabExt.boolType);
        if (!des.isSemanticError()
             && check_type_and_report(des.getObj(), listType, desleft, " prvi argument READ-a mora biti char, bool ili int"))
        {
            if (des.isLeftValue())
            {
                Code.put(Code.pop);
                if (typesEqual(des.getObj().getType(), Tab.charType))
                {
                    Code.put(Code.bread);
                }
                else
                {
                    Code.put(Code.read);
                }
                Code.store(des.getObj());
            }
            else
            {
                semantic_error("Parametar kod read mora da bude lvalue. ", desleft);
            }
        }
        parser.log.debug("Prepoznat READ", null);
    :}
    |
    PRINT PAR_LEFT Expr:expr CommaConstNumEpsilon:numObj PAR_RIGHT SEMI_COLUMN
    {:
        LinkedList<Struct> listType = new LinkedList<Struct>();
        listType.addLast(Tab.intType);
        listType.addLast(Tab.charType);
        listType.addLast(TabExt.boolType);
        if (!expr.isSemanticError()
        && check_type_and_report(expr.getObj(), listType, exprleft, " prvi argument PRINT-a mora biti char, bool ili int"))
        {
            if (numObj != null)
            {
                Code.load(numObj);
            }
            else
            {
                Code.loadConst(0);
            }
            if (typesEqual(expr.getObj().getType(), Tab.charType))
            {
                Code.put(Code.bprint);
            }
            else
            {
                Code.put(Code.print);
            }
        }
        else
        {
            expr.setSemanticError(true);
        }
        RESULT = expr;
        parser.log.debug("Prepoznat PRINT");
    :}
    |
    BRACE_LEFT StatementListEpsilon BRACE_RIGHT
    {:
        ParserCnt.blockCnt++;
        parser.log.debug("Prepoznat BLOK", null);
    :}
    ;

ElseStatementEpsilon ::=
        ELSE
        Statement

        {:
            parser.log.debug("Prepoznat ELSE", null);
        :}
        |
        /* epsilon */
        ;

ExprEpsilon ::=
        Expr:expr
        {:
            RESULT = expr;
        :}
        |
        {:
            RESULT = null;
        :}
        /* epsilon */
        ;



ForConditionSemi ::=
        ForCondition:forCond SEMI_COLUMN
        {:
            RESULT = forCond;
        :}
        |
        SEMI_COLUMN
        {:
            Code.loadConst(1);
            RESULT = new ObjResultWrapper(new Obj(Obj.Con, "", TabExt.boolType));
        :}
        |
        error SEMI_COLUMN
        {:
              parser.report_error("Uspesan oporavak od greske kod uslova u for-u,  SEMI_COLUMN je resio stvar" , null);
              RESULT = (new ObjResultWrapper()).setSyntaxError(true);
        :}
        ;

CommaConstNumEpsilon ::=
        COMMA CONST_NUM:number
        {:
            RESULT = new Obj(Obj.Con, number.toString(), Tab.intType, number.intValue(), numberleft);
        :}
        |
        {:
            RESULT = null;
        :}
        ;

/* ovde moze biti igranja */
/******************* Designator Statement *******************/
/************************************************************/


DesignatorStatementOrAssign ::=

            DesignatorStatement
            |
            AssingmentStatement
            |
            /* epsilon */
            ;

DesignatorStatementOrAssignOrErrorParRight ::=
            DesignatorStatement PAR_RIGHT
            |
            AssingmentStatement PAR_RIGHT
            |
            PAR_RIGHT
            |
            error PAR_RIGHT
            {:
                  parser.report_error("Uspesan oporavak od greske kod inkrementatorra u for-u,  PAR_RIGHT je resio stvar" , null);
            :}
            ;

DesignatorStatementOrAssignErrorSemi ::=
        DesignatorStatement SEMI_COLUMN
        |
        AssingmentStatementOrErrorSemi:expr
        {:
            RESULT = expr;
        :}
        ;


DesignatorStatement ::=
        DesignatorIncOrDec:incOrDec
        {:
            RESULT = incOrDec;
        :}
        |
        DesignatorFuncCall:funcCall
        {:
            if (!funcCall.isError() && (funcCall.getObj().getType() != Tab.noType))
            {
                Code.put(Code.pop);
            }
            RESULT = funcCall;
        :}
        ;

DesignatorIncOrDec ::=
    Designator:designator IncOrDec:op
    {:

        if (!designator.isSemanticError())
        {
            if (designator.isLeftValue())
            {
                if (check_type_and_report(designator.getObj(), Tab.intType, designatorleft, "Izraz koji se inkrementira/dekrementira mora da bude int"))
                {
                    // right value is not needed
                    // because a i a[i] is good because there is no inc
                    Code.loadConst(1);
                    Code.put(op);
                    Code.store(designator.getObj());
                    designator.promoteToConst();
                    RESULT = designator;
                }
                else
                {
                    RESULT = designator.setSemanticError(true);
                }
            }
            else
            {
                semantic_error("Izraz koji se inkrementira/dekrementira mora da bude lvalue.", designatorleft);
                RESULT = designator.setSemanticError(true);
            }
        }
        else
        {
            RESULT = designator.setSemanticError(true);
        }
    :}
    ;

IncOrDec ::=
    OP_INC
    {:
        RESULT = Code.add;
    :}
    |
    OP_DEC
    {:
        RESULT = Code.sub;
    :}
    ;

DesignatorFuncCall ::=
    Designator:func
    PAR_LEFT
    {:
        listActParCnt.addLast(0);
        if (!func.isError())
        {
            if (func.getObj().getKind() == Obj.Meth)
            {
                if (isMethodVirtual(func.getObj()))
                {
                    incLastPar(listActParCnt);
                    // adr
                    Code.put(Code.dup);

                    // adr adr
                }
            }
            else
            {
                semantic_error("Ovde treba da bude globalna funkcija/staticka metoda/virtuelna metoda", funcleft);
                func.setSemanticError(true);
            }
        }
        listCurObjWrapperFuncCall.addLast(func);
        if (!curObjWrapperMethod.isError() && METHOD_ENTRY_NAME.equals(curObjWrapperMethod.getObj().getName())) {
            ParserCnt.funcCallInMainCnt++;
        }

    :}

    ActParsEpsilon PAR_RIGHT
    {:
        if (!func.isError())
        {
            if (listActParCnt.getLast() == countFormPars(func.getObj()))
            {
                if (isMethodVirtual(func.getObj()))
                {
                    String funcName = func.getObj().getName();
                    // VFT_POINTER
                    Code.put(Code.getfield);
                    Code.put2(0);
                    Code.put(Code.invokevirtual);
                    for (int idx = 0; idx < funcName.length(); idx ++)
                    {
                        Code.put4((int)funcName.charAt(idx));
                    }
                    Code.put4(-1);
                }
                else
                {
                    Code.put(Code.call);
                    // Because Code.call is put then pc  = pc + 1.
                    //
                    int adr = func.getObj().getAdr() - Code.pc + 1;
                    Code.put2(adr);
                }
            }
            else
            {
                semantic_error("Broj argumenata u pozivu funkcije nije isti kao broj argumenata u definiciji.", funcleft);
                func.setSemanticError(true);
            }
        }
        listCurObjWrapperFuncCall.removeLast();
        listActParCnt.removeLast();
        RESULT = func;
    :}
    |
    Designator PAR_LEFT error PAR_RIGHT
    {:
       parser.report_error("Uspesan oporavak od greske kod poziva metode/funkcije/staticke metode,  PAR_RIGHT je resio stvar" , null);
       RESULT = (new ObjResultWrapper()).setSyntaxError(true);
    :}
    ;
// list of Obj of Method.
ActParsEpsilon ::=
        ActPars:actPar
        {:
            RESULT = actPar;
        :}
        |
        {:
            RESULT = null;
        :}
        /* epsilon */
        ;

AssingmentStatement ::=
        Designator:dest
        Assignop:op
        {:
            if (!dest.isError())
            {
                if (dest.isLeftValue())
                {
                    if ( dest.hasAdditionalParsOnStack() && op == OP_ASSIGN_CODE)
                    {
                        // a i a[i]
                        // c c.x
                        Code.put(Code.pop);
                        // a i
                        // c
                    }
                }
                else
                {
                    semantic_error("Levi izraz kod dodele mora da bude lvalue.", destleft);
                    RESULT = dest.setSemanticError(true);

                }
            }

        :}
        Expr : expr
        {:
            if (!dest.isError() && !expr.isError())
            {
                if (typesAssignable(dest.getObj().getType(), expr.getObj().getType()))
                {
                    if (op != OP_ASSIGN_CODE)
                    {
                        // Vrednost na steku nije duplirana jer
                        // treba samo da se koristi za izracunavanje
                        // Nista za dalje vrednosti.
                        Code.put(op);
                    }
                    Code.store(dest.getObj());
                    if ( (op == OP_ASSIGN_CODE)
                        && !dest.hasAdditionalParsOnStack())
                    {
                        Code.put(Code.pop);
                    }
                }
                else
                {
                    semantic_error("Vrednosti izraza pri dodeli nisu kompatibilne.", destleft);
                    RESULT = dest.setSemanticError(true);
                    }
            }
            else
            {
                RESULT = dest.propagateError(expr);
            }
        :}
        ;

AssingmentStatementOrErrorSemi ::=
    Designator:dest
    Assignop:op
    {:
        if (!dest.isError())
        {
            if (dest.isLeftValue())
            {
                if ( dest.hasAdditionalParsOnStack() && op == OP_ASSIGN_CODE)
                {
                    // a i a[i]
                    // c c.x
                    Code.put(Code.pop);
                    // a i
                    // c
                }
            }
            else
            {
                semantic_error("Levi izraz kod dodele mora da bude lvalue.", destleft);
                RESULT = dest.setSemanticError(true);

            }
        }

    :}
    ExpOrErrorSemi : expr
    {:
        // Check error.
        //
        if (!dest.isError() && !expr.isError())
        {
            if (typesAssignable(dest.getObj().getType(),
                expr.getObj().getType()))
            {
                if (op != OP_ASSIGN_CODE)
                {
                    // Vrednost na steku nije duplirana jer
                    // treba samo da se koristi za izracunavanje
                    // Nista za dalje vrednosti.
                    Code.put(op);
                }
                Code.store(dest.getObj());
                if ( (op == OP_ASSIGN_CODE)
                    && !dest.hasAdditionalParsOnStack())
                {
                    Code.put(Code.pop);
                }
            }
            else
            {
                semantic_error("Vrednosti izraza pri dodeli nisu kompatibilne.", destleft);
                RESULT = dest.setSemanticError(true);
            }
        }
        else
        {
            RESULT = dest.propagateError(expr);
        }
    :}
    ;

ExpOrErrorSemi ::=
        Expr:expr SEMI_COLUMN
        {:
            RESULT = expr;
        :}
        |
        error SEMI_COLUMN
        {:

            parser.report_error("Uspesan oporavak od greske dodele promenljive,  SEMI_COLUMN je resio stvar", null);
            RESULT = (new ObjResultWrapper()).setSyntaxError(true);
        :}
        ;

/******************* ActPars  *******************************/
/************************************************************/
ActPars ::=
    Expr:expr
    {:
        incLastPar(listActParCnt);
        if (!listCurObjWrapperFuncCall.getLast().isError())
        {
            if(isMethodVirtual(listCurObjWrapperFuncCall.getLast().getObj()))
            {
                // adr adr par
                Code.put(Code.dup_x1);
                // adr par adr par
                Code.put(Code.pop);
                //adr par adr
            }
            if (!expr.isError())
            {
                Obj formParOnIdx = getFormPar(listCurObjWrapperFuncCall.getLast().getObj(),
                                                    listActParCnt.getLast());
                if ( (formParOnIdx == null)
                    || ( (!typesCompatibile(expr.getObj().getType(), formParOnIdx.getType()))
                        && ((listCurObjWrapperFuncCall.getLast().getObj() != lenObj)
                            || !expr.isArray())) )
                {
                    semantic_error("Tipovi nisu kompatibilni, parametar:" + listActParCnt.getLast(), exprleft);
                    expr.setSemanticError(true);
                }

            }
        }
        {
            expr.propagateError(listCurObjWrapperFuncCall.getLast());
        }
    :}
    CommaExprListEpsilon:exprList
    {:
        RESULT = expr.propagateError(exprList);
    :}
    ;

CommaExprListEpsilon ::=
        CommaExprList:exprList
        {:
            RESULT = exprList;
        :}
        |
        {:
            RESULT = null;
        :}
        /* epsilon */
        ;
CommaExprList ::=
        CommaExprList:exprList CommaExpr:expr
        {:
            RESULT = exprList.propagateError(expr);
        :}
        |
        CommaExpr:expr
        {:
            RESULT = expr;
        :}
        ;
CommaExpr ::=
    COMMA Expr:expr
    {:
        incLastPar(listActParCnt);
        if (!listCurObjWrapperFuncCall.getLast().isError())
        {
            if(isMethodVirtual(listCurObjWrapperFuncCall.getLast().getObj()))
            {
                // adr adr par
                Code.put(Code.dup_x1);
                // adr par adr par
                Code.put(Code.pop);
                //adr par adr
            }
            if (!expr.isError())
            {
                Obj formParOnIdx = getFormPar(listCurObjWrapperFuncCall.getLast().getObj(),
                                    listActParCnt.getLast());
                if ( (formParOnIdx == null)
                    || ( (!typesCompatibile(expr.getObj().getType(), formParOnIdx.getType()))
                        && ((listCurObjWrapperFuncCall.getLast().getObj() != lenObj)
                            || !expr.isArray())) )
                {
                    semantic_error("Tipovi nisu kompatibilni, parametar:"+ listActParCnt.getLast(), exprleft);
                    expr.setSemanticError(true);
                }

            }
            RESULT = expr;
        }
        {
            RESULT = expr.propagateError(listCurObjWrapperFuncCall.getLast());
        }
    :}
    ;

/******************* Condition  *****************************/
/************************************************************/
ForCondition ::=
            OpOrCondTermList:opOrList
            {:
                RESULT = opOrList;
            :}
            ;
IfConditionParRight ::=
            OpOrCondTermList:cond PAR_RIGHT
            {:
                RESULT = cond;
            :}
            |
            error PAR_RIGHT
            {:
                parser.report_error("Uspesan oporavak od greske prilikom definisanja uslova za if PAR_RIGHT je resila stvar", null);
                RESULT = (new ObjResultWrapper()).setSyntaxError(true);
            :}
            ;
OpOrCondTermList ::=
        OpOrCondTermList:leftCond OP_OR OpAndCondFactList:rightCond
        // TODO : add checks
        //
        {:
            if (!leftCond.isError() && !rightCond.isError())
            {
                Code.put(Code.add);
                RESULT = leftCond.propagateError(rightCond);
            }
            else
            {
                RESULT = leftCond;
            }
        :}
        |
        OpAndCondFactList:fact
        {:
            RESULT = fact;
        :}
        ;

/******************* CondTerm   *****************************/
/************************************************************/
OpAndCondFactList ::=
        OpAndCondFactList:leftFact OP_AND CondFact:rightFact
        // TODO add check if is boolType
        //
        {:
            if (!leftFact.isError() && !rightFact.isError())
            {
                Code.put(Code.mul);
                RESULT = leftFact;
            }
            else
            {
                RESULT = leftFact.propagateError(rightFact);
            }
        :}
        |
        CondFact:condFact
        {:
            RESULT = condFact;
        :}
        ;

/******************* CondFact   *****************************/
/************************************************************/
CondFact ::=
    Expr:expr
    RelOpExprOrEpsilon:compareRight
    {:
        if (!expr.isError() && ( (null ==compareRight) || !compareRight.isError()))
        {
            if (null == compareRight)
            {
                if(check_type_and_report(expr.getObj(), TabExt.boolType, exprleft, "Tip kod logickog izraza mora biti boolean"))
                {
                    RESULT = expr.setSemanticError(true);
                }
                else
                {
                    RESULT = expr;
                }
            }
            else
            {
                if (typesCompatibile(expr.getObj().getType(), compareRight.getObj().getType()))
                {
                    if ( (expr.isClass() || compareRight.isClass() || expr.isArray() || compareRight.isArray())
                        && ( (compareRight.getRelOp() != Code.eq) && (compareRight.getRelOp() != Code.ne)))
                    {
                        semantic_error("Kad se porede nizovi/klase sme da se koristi samo != i ==", exprleft);
                        RESULT = (new ObjResultWrapper()).setSemanticError(true);
                    }
                    else
                    {
                        // JCONDFALSE.
                        //
                        Code.putFalseJump(compareRight.getRelOp(), 0);
                        int adrFromWhereToJumpFalse = Code.pc - 2;
                        // TRUE.
                        //
                        Code.put(Code.const_1);
                        Code.putJump(0);
                        int adrFromWhereToJumpTrue = Code.pc - 2;

                        Code.fixup(adrFromWhereToJumpFalse);
                        // False.
                        //
                        Code.put(Code.const_n);
                        // JMP over this
                        Code.fixup(adrFromWhereToJumpTrue);
                        RESULT = new ObjResultWrapper(new Obj(Obj.Con, "", TabExt.boolType));
                    }
                }
                else
                {
                    semantic_error("Tipovi kod poredjenja nisu kompatibilni.", exprleft);
                    RESULT = (new ObjResultWrapper()).setSemanticError(true);
                }
            }

        }
        else
        {
            RESULT = expr.propagateError(compareRight);
        }
    :}
    ;
RelOpExprOrEpsilon ::=
        Relop:relOp
        Expr:expr
        {:
            if (!expr.isError())
            {
                expr.setRelOp(relOp);
            }
            RESULT = expr;

        :}
        |
        /* epsilon */
        {:
            RESULT = null;
        :}
        ;


/******************* Expr       *****************************/
/************************************************************/
Expr ::=
    AddopRightTerm:term
    {:
        if (!term.isError())
        {
            term.generateRightValue();
        }
        RESULT = term;
    :}
    ;

AddopRightTerm ::=
    AddopLeftTerm:leftTerm AddopRight:op

    AddopRightTerm:rightTerm
    {:
       if (!leftTerm.isError() && !rightTerm.isError())
       {
        if (
            check_type_and_report(leftTerm.getObj(), Tab.intType, rightTermleft, " Levi sabirak / umanjenik mora biti tipa int.")
            && check_type_and_report(rightTerm.getObj(), Tab.intType, rightTermleft, " Desni sabirak / umanjilac mora biti tipa int."))
            {
                if (leftTerm.isLeftValue())
                {
                    rightTerm.generateRightValue();
                    Code.put(op);
                    if (leftTerm.isArrayElement())
                    {
                        // a i sum
                        Code.put(Code.dup_x2);
                        // sum a i sum
                    }
                    else if (leftTerm.isField())
                    {
                        // c sum
                        Code.put(Code.dup_x1);
                        // sum c sum
                    }
                    else
                    {
                        Code.put(Code.dup);
                    }
                    // sum
                    Code.store(leftTerm.getObj());

                    leftTerm.promoteToConst();
                    RESULT = leftTerm;
                }
                else
                {
                    semantic_error("Kod += -= leva strana treba da bude lvalue");
                    RESULT = leftTerm.setSemanticError(true);
                }
            }
            else
            {
                RESULT = leftTerm.setSemanticError(true);
            }
        }
        else
        {
            RESULT = leftTerm.propagateError(rightTerm);
        }
    :}
    |
    AddopLeftTerm:type
    {:
        RESULT = type;
    :}
    ;
AddopLeftTerm ::=
    AddopLeftTerm:leftTerm AddopLeft:op Term:rightTerm
    {:
        if (!leftTerm.isError() && !rightTerm.isError())
        {
            if (check_type_and_report(leftTerm.getObj(), Tab.intType, leftTermleft, " Tip levog sabirka/umanjenika u zbiru/proizvodu mora da bude int")
                &&
                check_type_and_report(rightTerm.getObj(), Tab.intType, rightTermleft, " Tip desnog sabirka/umanjioca u zbiru/razlici mora biti int"))
                {
                    rightTerm.generateRightValue();
                    Code.put(op);
                    leftTerm.generateRightValue();
                    RESULT = leftTerm;
            }
            else
            {
                RESULT = leftTerm.setSemanticError(true);
            }
        }
        else
        {
            RESULT = leftTerm.propagateError(rightTerm);
        }
    :}
    |
    OP_SUB Term:term
    {:
        if (!term.isError())
        {
            if (check_type_and_report(term.getObj(), Tab.intType, termleft, " Kad se - nalazi ispred nekog izraza, on mora biti int."))
            {
                term.generateRightValue();
                Code.put(Code.neg);
                RESULT = term;
            }
            else
            {
                RESULT = term.setSemanticError(true);
            }
        }
        else
        {
            RESULT = term;
        }
    :}
    |
    Term:term
    {:
        RESULT = term;
    :}
    ;

/**********************   Term       *****************************/
/*****************************************************************/
Term ::=
            MullopRightFactor:rightFactor
            {:
                RESULT = rightFactor;
            :}
            ;

MullopRightFactor ::=
    MulopLeftFactor:leftFactor
    MulopRight:op
    // a i expr -> expr a i expr
    MullopRightFactor:rightFactor
    {:
        // TODO: Treba dodati provere za polja i sve ostale gluposti
        //
        if (!leftFactor.isError() && !rightFactor.isError())
        {
            if (check_type_and_report(leftFactor.getObj(), Tab.intType, leftFactorleft, " Levi cinilac / deljenik mora biti tipa int.")
            && check_type_and_report(rightFactor.getObj(), Tab.intType, rightFactorleft, " Desni cinilac / delilac mora biti tipa int."))
            {
                if (leftFactor.isLeftValue())
                {
                    rightFactor.generateRightValue();
                    Code.put(op);
                    if (leftFactor.isArrayElement())
                    {
                        Code.put(Code.dup_x2);
                    }
                    else if (leftFactor.isField())
                    {
                        Code.put(Code.dup_x1);
                    }
                    else
                    {
                        Code.put(Code.dup);
                    }

                    Code.store(leftFactor.getObj());
                    leftFactor.promoteToConst();
                    RESULT = leftFactor;
                }
                else
                {
                    semantic_error("Kod /= *= %= leva strana treba da bude lvalue.", rightFactorleft);
                    RESULT = leftFactor.setSemanticError(true);
                }
            }
        else
        {
            RESULT = leftFactor.setSemanticError(true);
        }
    }
    else
    {
        RESULT = leftFactor.propagateError(rightFactor);
    }
    :}
    |
    MulopLeftFactor:factor
    {:
        RESULT = factor;
    :}
    ;

MulopLeftFactor ::=
        MulopLeftFactor:leftFactor
        MulopLeft:op
        Factor:rightFactor
        {:
            if (!leftFactor.isError() && !rightFactor.isError())
            {
                if (check_type_and_report(leftFactor.getObj(), Tab.intType, leftFactorleft, " Tip levog cinioca/deljenika u proizvodu mora da bude int")
                &&
                    check_type_and_report(rightFactor.getObj(), Tab.intType, rightFactorleft, " Tip desnog cinioca/delioca mora biti int"))
                {
                    rightFactor.generateRightValue();
                    Code.put(op);
                    leftFactor.generateRightValue();
                    RESULT = leftFactor;
                }
                else
                {
                    RESULT = leftFactor.setSemanticError(true);
                }
            }
            else
            {
                RESULT = leftFactor.propagateError(rightFactor);
            }
        :}
        |
        Factor:factor
        {:
            RESULT = factor;
        :}
        ;

/**********************   Factor     *****************************/
/*****************************************************************/

Factor ::=
        DesignatorFuncCall:func
        {:
            RESULT = func;
        :}
        |
        Designator:designator
        {:
            RESULT = designator;
        :}
        |
        ConstValue:constValue
        {:
            Code.load(constValue);
            RESULT = new ObjResultWrapper(constValue);
        :}
        |
        NEW Type:type BracketExprEpsilon:exprWrap
        {:
            if (null != exprWrap)
            {
                if (!exprWrap.isSemanticError()
                    && !type.isSemanticError()
                    && check_type_and_report(exprWrap.getObj(),
                                          Tab.intType,
                                         exprWrapleft,
                                         "Tip izraza kod NEW operatora sa nizom mora da bude int"))
                {
                    detectSymbolInfo(type.getObj(), typeleft);
                    Code.put(Code.newarray);
                    if (typesEqual(type.getObj().getType(), Tab.charType))
                    {
                        Code.put(0);
                    }
                    else
                    {
                        Code.put(1);
                    }
                    Struct struct = new Struct(Struct.Array, type.getObj().getType());
                    RESULT = new ObjResultWrapper(new Obj(Obj.Con, "", struct));
                }
                else
                {
                    RESULT = (new ObjResultWrapper()).setSemanticError(true);
                }
            }
            else
            {
                if (!type.isSemanticError())
                {
                    // For sur is type if it's not a semantic error
                    if  (type.getObj().getType().getKind() == Struct.Class)
                    {
                        detectSymbolInfo(type.getObj(), typeleft);
                        Code.put(Code.new_);
                        Code.put2(type.getObj().getType().getNumberOfFields() * INT_SIZE);
                        // adr
                        Code.put(Code.dup);
                        // adr adr
                        Code.loadConst(type.getObj().getAdr());
                        // adr adr val
                        // TODO add check if class is not initialized.
                        //
                        Code.store(type.getObj().getType().getMembersTable().searchKey(VFT_POINTER_NAME));
                        RESULT = new ObjResultWrapper(new Obj(Obj.Con, "", type.getObj().getType()));
                    }
                    else
                    {
                        semantic_error(type.getObj().getName() + " nije tip unutrasnje klase", typeleft);
                        RESULT = (new ObjResultWrapper()).setSemanticError(true);
                    }
                }
                else
                {
                    RESULT = (new ObjResultWrapper()).setSemanticError(true);
                }

            }
        :}
        |
        PAR_LEFT Expr:result PAR_RIGHT
        {:
            RESULT = result;
        :}
        ;
BracketExprEpsilon ::=
            BRACKET_LEFT Expr:expr BRACKET_RIGHT
            {:
                RESULT = expr;
            :}
            |
            {:
                RESULT = null;
            :}
            /* epsilon */
            ;


/**********************   Designator   ***************************/
/*****************************************************************/
Designator ::=
    IDENT:name
    {:
        curObjWrappFieldOrElem = find_for_use_and_report(name, nameleft, name);

        if (!curObjWrappFieldOrElem.isError())
        {
            if (isInClass)
            {
                if (!curObjWrapperMethod.isError())
                {
                    if (isMethodStatic(curObjWrapperMethod.getObj()))
                    {
                        if (curObjWrappFieldOrElem.isField() ||
                         ((curObjWrappFieldOrElem.getObj().getKind() == Obj.Meth)
                            && isMethodVirtual(curObjWrappFieldOrElem.getObj())))
                        {
                            semantic_error("Ne moze se referncirati polje/virtuelna metoda iz staticke metode", nameleft);
                            curObjWrappFieldOrElem.setSemanticError(true);
                        }
                    }
                    else
                    {
                        if (curObjWrappFieldOrElem.isField())
                        {
                            Code.load(Tab.find("this"));
                            Code.put(Code.dup);
                        }
                        else if ((curObjWrappFieldOrElem.getObj().getKind() == Obj.Meth)
                            && isMethodVirtual(curObjWrappFieldOrElem.getObj()))
                        {
                            Code.load(Tab.find("this"));
                            //curObjWrappFieldOrElem.setVirtual(true);
                        }
                    }
                }
                else
                {
                    curObjWrappFieldOrElem.propagateError(curObjWrapperMethod);
                }
            }

            listCurObjWrapperFieldOrElem.addLast(curObjWrappFieldOrElem);
            if (curObjWrappFieldOrElem.loadable())
            {
                Code.load(curObjWrappFieldOrElem.getObj());
            }

        }

    :}
    DotIdentOrBracketExprListEpsilon:objWrapper
    {:
        if (!curObjWrappFieldOrElem.isError())
        {
            if(objWrapper == null)
            {
                RESULT = curObjWrappFieldOrElem;
            }
            else if ( (objWrapper != null) && (!objWrapper.isError()) )
            {
                RESULT = objWrapper;
            }
            else
            {
                RESULT = objWrapper;
            }
        }
        else
        {
            RESULT = curObjWrappFieldOrElem;
        }

        if (!curObjWrappFieldOrElem.isError())
        {
            listCurObjWrapperFieldOrElem.removeLast();
            if (listCurObjWrapperFieldOrElem.size() != 0)
            {
                curObjWrappFieldOrElem = listCurObjWrapperFieldOrElem.getLast();
            }
            else
            {
                curObjWrappFieldOrElem = null;
            }
        }

    :}
    ;
DotIdentOrBracketExprListEpsilon ::=
        DotIdentOrBracketExprList:objWrap
        {:
            RESULT = objWrap;
        :}
        |
        {:
            RESULT = null;
        :}
        /* epsilon */
        ;
DotIdentOrBracketExprList ::=
        DotIdentOrBracketExprList:left DotIdentOrBracketExpr:objWrapper
        {:
            if (left.isError() || objWrapper.isError())
            {
                objWrapper.propagateError(left);
            }
            else
            {
                RESULT = objWrapper;
            }

        :}
        |
        DotIdentOrBracketExpr:objWrapper
        {:

            RESULT = objWrapper;
        :}
        ;
DotIdentOrBracketExpr ::=
    DOT IDENT:memberName
    {:
        if (!curObjWrappFieldOrElem.isError())
        {
            if (curObjWrappFieldOrElem.isClassType())
            {
                Obj obj = curObjWrappFieldOrElem.getObj().getType().getMembersTable().searchKey(memberName);
                if (obj == null)
                {
                    semantic_error("Ne postoji clan sa datim imenom", memberNameleft);
                    RESULT = curObjWrappFieldOrElem.setSemanticError(true);
                }
                else if (obj.getKind() != Obj.Meth)
                {
                    semantic_error("Ne postoji metoda unutar date klase sa datim imenom", memberNameleft);
                    RESULT = curObjWrappFieldOrElem.setSemanticError(true);
                }
                else if (!(isMethodStatic(obj)))
                {
                    semantic_error("Metoda sa datim imenom nije staticka", memberNameleft);
                    RESULT = curObjWrappFieldOrElem.setSemanticError(true);
                }
                else
                {
                    detectSymbolInfo(obj, memberNameleft);
                    curObjWrappFieldOrElem.copyTo(new ObjResultWrapper(obj));
                    RESULT = curObjWrappFieldOrElem;
                }
            }
            else if (curObjWrappFieldOrElem.isClass())
            {
                Obj obj = curObjWrappFieldOrElem.getObj().getType().getMembersTable().searchKey(memberName);
                if (obj == null)
                {
                    semantic_error("Ne postoji clan sa datim imenom", memberNameleft);
                    RESULT = curObjWrappFieldOrElem.setSemanticError(true);
                }
                else if ( (obj.getKind() != Obj.Meth) && (obj.getKind() != Obj.Fld))
                {
                    semantic_error("Ne postoji clan unutar date klase sa datim imenom", memberNameleft);
                    RESULT = curObjWrappFieldOrElem.setSemanticError(true);
                }
                else
                {
                    detectSymbolInfo(obj, memberNameleft);
                    curObjWrappFieldOrElem.generateRightValue();
                    if ( (obj.getKind() == Obj.Meth) && (isMethodStatic(obj)) )
                    {
                        Code.put(Code.pop);
                        curObjWrappFieldOrElem.copyTo(new ObjResultWrapper(obj));
                        RESULT = curObjWrappFieldOrElem;
                    }
                    else
                    {
                        //curObjWrappFieldOrElem.generateRightValue();
                        if (obj.getKind() == Obj.Fld)
                        {
                            // x
                            Code.put(Code.dup);
                            // x x
                            Code.load(obj);
                            // x x.i

                            curObjWrappFieldOrElem.copyTo(new ObjResultWrapper(obj));
                            RESULT = curObjWrappFieldOrElem;
                        }
                        else
                        {
                            curObjWrappFieldOrElem.copyTo(new ObjResultWrapper(obj));
                            //curObjWrappFieldOrElem.setVirtual(true);
                            RESULT = curObjWrappFieldOrElem;
                        }
                    }
                }
            }
            else
            {
                semantic_error("Sa desne strane . mora da bude tipa unutrasnje klase", memberNameleft);
                RESULT = curObjWrappFieldOrElem.setSemanticError(true);
            }
        }
        else
        {
            RESULT = curObjWrappFieldOrElem;
        }
    :}
    |
    BRACKET_LEFT
    {:
        curObjWrappFieldOrElem.generateRightValue(false/*promoteToConst*/);
    :}
    Expr:expr BRACKET_RIGHT
    {:
        if (!curObjWrappFieldOrElem.isError() && !expr.isError())
        {
            if (check_type_and_report(expr.getObj(), Tab.intType, exprleft, " indeks niza mora bude tipa int"))
            {
                if (curObjWrappFieldOrElem.isArray())
                {

                    Struct curArrayDotType = curObjWrappFieldOrElem.getObj().getType().getElemType();
                    Obj obj = new Obj(Obj.Elem, "", curArrayDotType);
                    detectSymbolInfo(obj, exprleft);
                    curObjWrappFieldOrElem.copyTo(new ObjResultWrapper(obj));
                    Code.put(Code.dup2);
                    Code.load(obj);
                    RESULT = new ObjResultWrapper(obj);
                }
                else
                {
                    semantic_error("Kad se koriste [] sa leve strane mora biti niz", exprleft);
                    RESULT = curObjWrappFieldOrElem.setSemanticError(true);
                }
            }
            else
            {
                RESULT = curObjWrappFieldOrElem.setSemanticError(true);

            }
        }
        else
        {
            RESULT = curObjWrappFieldOrElem.propagateError(expr);;
        }

    :}
    |
    BRACKET_LEFT error BRACKET_RIGHT
    {:
        parser.report_error("Uspesan oporavak od greske kod indeksa niza,  BRACKET_RIGHT je resio stvar" , null);
        RESULT = new ObjResultWrapper().setSyntaxError(true);
    :}
    ;


/**********************   AssignOp    ****************************/
/*****************************************************************/
Assignop ::=
            OP_ASSIGN
            {:
                RESULT = OP_ASSIGN_CODE;
            :}
            |
            AddopRight:op
            {:
                RESULT = op;
            :}
            |
            MulopRight:op
            {:
                RESULT = op;
            :};


/**********************   Relop       ****************************/
/*****************************************************************/
Relop ::=
            OP_EQ
            {:
                RESULT = Code.eq;
            :}
            |
            OP_NOT_EQ
            {:
                RESULT = Code.ne;
            :}
            |
            OP_GTE
            {:
                RESULT = Code.ge;
            :}
            |
            OP_GREAT
            {:
                RESULT = Code.gt;
            :}
            |
            OP_LESS
            {:
                RESULT = Code.lt;
            :}
            |
            OP_LTE
            {:
                RESULT = Code.le;
            :}
            ;



/**********************   AddopLeft   ****************************/
/*****************************************************************/
AddopLeft ::=
            OP_ADD
            {:
                RESULT = Code.add;
            :}
            |
            OP_SUB
            {:
                RESULT = Code.sub;
            :}
            ;


/**********************   AddopRight  ****************************/
/*****************************************************************/
AddopRight ::=
            OP_ASSIGN_ADD
            {:
                RESULT = Code.add;
            :}
            |
            OP_ASSIGN_SUB
            {:
                RESULT = Code.sub;
            :}
            ;


/**********************   MulopLeft   ****************************/
/*****************************************************************/
MulopLeft ::=
            OP_MUL
            {:
                RESULT = Code.mul;
            :}
            |
            OP_DIV
            {:
                RESULT = Code.div;
            :}
            |
            OP_MOD
            {:
                RESULT = Code.rem;
            :}
            ;


/**********************   MulopRight  ****************************/
/*****************************************************************/
MulopRight ::=
            OP_ASSIGN_MUL
            {:
                RESULT = Code.mul;
            :}
            |
            OP_ASSIGN_DIV
            {:
                RESULT = Code.div;
            :}
            |
            OP_ASSIGN_MOD
            {:
                RESULT = Code.rem;
            :}
            ;

