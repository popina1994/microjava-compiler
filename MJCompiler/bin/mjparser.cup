package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

import java.io.*;
import java.util.LinkedList;
import java.util.Collection;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.mj.runtime.*;
import rs.etf.pp1.symboltable.visitors.SymbolTableVisitor;

parser code {:

    public static class DumpUpgradeSymbolTableVisitor extends SymbolTableVisitor
    {
        protected StringBuilder output = new StringBuilder();
        protected final String indent = "   ";
        protected StringBuilder currentIndent = new StringBuilder();

        protected void nextIndentationLevel() {
            currentIndent.append(indent);
        }

        protected void previousIndentationLevel() {
            if (currentIndent.length() > 0)
                currentIndent.setLength(currentIndent.length()-indent.length());
        }


        /* (non-Javadoc)
         * @see rs.etf.pp1.symboltable.test.SymbolTableVisitor#visitObjNode(symboltable.Obj)
         */
        @Override
        public void visitObjNode(Obj objToVisit) {
            //output.append("[");
            switch (objToVisit.getKind()) {
            case Obj.Con:  output.append("Con "); break;
            case Obj.Var:  output.append("Var "); break;
            case Obj.Type: output.append("Type "); break;
            case Obj.Meth: output.append("Meth "); break;
            case Obj.Fld:  output.append("Fld "); break;
            case Obj.Prog: output.append("Prog "); break;
            }

            output.append(objToVisit.getName());
            output.append(": ");

            if ( (objToVisit.getKind() == Obj.Meth) && (objToVisit.getType().getKind() == Struct.Class))
            {
                output.append("Class ");
                output.append(objToVisit.getType());
                output.append(", ");
                output.append("Adr:" + objToVisit.getAdr());
                output.append(", ");
                output.append("Level:" + objToVisit.getLevel() + " ");
            }
            else
            {
                objToVisit.getType().accept(this);
                output.append(", ");
                output.append("Adr:" + objToVisit.getAdr());
                output.append(", ");
                output.append("Level:" + objToVisit.getLevel() + " ");
            }

            if (objToVisit.getKind() == Obj.Prog || objToVisit.getKind() == Obj.Meth) {
                output.append("\n");
                nextIndentationLevel();
            }


            for (Obj o : objToVisit.getLocalSymbols()) {
                output.append(currentIndent.toString());
                if ((objToVisit.getKind() == Obj.Meth) &&(o.getType().getKind() == Struct.Class))
                {
                    output.append("Var ");
                    output.append(o.getName());
                    output.append(": ");
                    output.append("Class ");
                    output.append(o.getType());
                    output.append(", ");
                    output.append("Adr:" + o.getAdr());
                    output.append(", ");
                    output.append("Level:" + o.getLevel() + " ");
                }
                else
                {
                    o.accept(this);
                }
                output.append("\n");
            }

            if (objToVisit.getKind() == Obj.Prog || objToVisit.getKind() == Obj.Meth)
                previousIndentationLevel();

            //output.append("]");

        }

        /* (non-Javadoc)
         * @see rs.etf.pp1.symboltable.test.SymbolTableVisitor#visitScopeNode(symboltable.Scope)
         */
        @Override
        public void visitScopeNode(Scope scope) {
            for (Obj o : scope.values()) {
                o.accept(this);
                output.append("\n");
            }
        }

        /* (non-Javadoc)
         * @see rs.etf.pp1.symboltable.test.SymbolTableVisitor#visitStructNode(symboltable.Struct)
         */
        @Override
        public void visitStructNode(Struct structToVisit) {
            switch (structToVisit.getKind()) {
            case Struct.None:
                output.append("notype");
                break;
            case Struct.Int:
                output.append("int");
                break;
            case Struct.Char:
                output.append("char");
                break;
            case Struct.Bool:
                output.append("bool");
                break;
            case Struct.Array:
                output.append("Arr of ");

                switch (structToVisit.getElemType().getKind()) {
                case Struct.None:
                    output.append("notype");
                    break;
                case Struct.Int:
                    output.append("int");
                    break;
                case Struct.Char:
                    output.append("char");
                    break;
                case Struct.Class:
                    output.append("Class");
                    break;
                case Struct.Bool:
                  output.append("bool");
                    break;
                }
                break;
            case Struct.Class:
                output.append("Class [\n");
                nextIndentationLevel();
                for (Obj obj : structToVisit.getMembers()) {
                    output.append(currentIndent.toString());
                    obj.accept(this);
                    if (obj.getKind() == Obj.Fld)
                    {
                        output.append("\n");
                    }
                }
                previousIndentationLevel();
                output.append(currentIndent.toString());
                output.append("]");
                break;
            }

        }

        public String getOutput() {
            StringBuilder tmp = output;
            output = new StringBuilder("");
            return tmp.toString();
        }

    }

    static class TabExt
    {
        static Struct boolType = new Struct(Struct.Bool);
        static SymbolTableVisitor symbolTableVisitor = new DumpUpgradeSymbolTableVisitor();
        static Obj programObj = null;
        static Obj curMethod = null;
        static Obj curClass = null;
        static boolean doesMainExist = false;
        static int staticDataCnt = 0;
    }

    public static class ObjResultWrapper {
        Obj obj;
        boolean isRightValue;
        boolean isLeftValue;
        boolean semanticError = false;
        boolean syntaxError = false;
        int relOp;
        boolean isVirtual = false;

        public ObjResultWrapper() {}

        public ObjResultWrapper(Obj obj, boolean isRightValue) {
            this.obj = obj;
            this.isRightValue = isRightValue;
            this.isLeftValue = !isRightValue;
        }

        public Obj getObj() {
            return obj;
        }
        public void setObj(Obj obj) {
            this.obj = obj;
        }

        public void setRightValue(boolean isRightValue) {
            this.isRightValue = isRightValue;
            this.isLeftValue = !isRightValue;
        }

        public void setLeftValue(boolean isLeftValue) {
            this.isLeftValue = isLeftValue;
            this.isRightValue = !isLeftValue;
        }

        public boolean isLeftValue() {
            return isLeftValue;
        }

        public boolean isSemanticError() {
            return semanticError;
        }

        public boolean isSyntaxError()
        {
            return syntaxError;
        }

        public ObjResultWrapper setSemanticError(boolean semanticError) {
            this.semanticError = semanticError;
            return this;
        }

        public ObjResultWrapper setSyntaxError(boolean syntaxError)
        {
            this.syntaxError = syntaxError;
            return this;
        }

        public boolean isError()
        {
            return (syntaxError || semanticError);
        }

        public boolean  isField()
        {
            return obj.getKind() == Obj.Fld && isLeftValue;
        }

        public boolean isClassType()
        {
            return (obj.getKind() == Obj.Type) && (obj.getType().getKind() == Struct.Class);
        }

        public boolean isArrayElement()
        {
            return obj.getKind() == Obj.Elem && isLeftValue;
        }

        public boolean isArray()
        {
            return (isLeftValue &&  (obj.getType().getKind() == Struct.Array) );
        }

        public boolean isClass()
        {
            return (isLeftValue && (obj.getType().getKind() == Struct.Class));
        }


        public boolean hasAdditionalParsOnStack()
        {
            return isArrayElement() || isField();
        }

        public boolean loadable()
        {
            int kind = obj.getKind();
            return (kind == Obj.Con) || (kind == Obj.Var) || (kind == Obj.Fld) || (kind == Obj.Elem);
        }

        public void generateRightValue()
        {
            if (isArrayElement())
            {
                // a i a[i]
                Code.put(Code.dup_x2);
                // a[i] a i a[i]
                Code.put(Code.pop);
                // a[i] a i
                Code.put(Code.pop);
                // a[i] a
                Code.put(Code.pop);
                // a[i]
                setRightValue(true);
            }
            else if (isField())
            {
                // x x.i
                Code.put(Code.dup_x1);
                // x.i x x.i
                Code.put(Code.pop);
                // x.i x
                Code.put(Code.pop);
                // x.i
                setRightValue(true);
            }
        }

        public boolean isVirtual()
        {
            return isVirtual;
        }

        public void setVirtual(boolean isVirtual)
        {
            this.isVirtual = isVirtual;
        }

        public void setRelOp(int relOp)
        {
            this.relOp = relOp;
        }

        public int getRelOp()
        {
            return relOp;
        }

    }


    // U slucaju greske.
    //
     @Override
    protected int error_sync_size() {
        // TODO Auto-generated method stubTab
        return 1;
    }

    static class ParserCnt {
        // NIVO A
        static int globalVarDefCnt = 0;
        static int localVarDefMainCnt = 0;
        static int globalConstDefCnt = 0;
        static int globalArrayDeclCnt = 0;

        // NIVO B
        static int globalAndStaticMethodCnt = 0;
        //static int l

        static boolean inVarDeclGlobalScope = false;
        static boolean inMethodDeclGlobalScope = false;
        static boolean inMethodEntryGlobalScope = false;
    }

    boolean errorDetected = false;
    boolean syntaxError = false;
    boolean semanticError = false;
    String fileName = "test/generator/program.obj";


    public void setFileName(String fileName){
        this.fileName = fileName;
    }

    Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    // MJParser greska.
    //
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    // Overrideovana MJParser funkcija.
    //
    public void syntax_error(Symbol cur_token) {
        syntaxError = true;
        report_error("\nSintaksna greska", cur_token);
    }

    public void semantic_error(String msg, Symbol sym)
    {
        semanticError = true;
        report_error("\nSemnaticka greska : " + msg, sym);
    }

    public void semantic_error(String msg)
    {
        semantic_error(msg, null);
    }

    public void semantic_error(String msg, int line)
    {
        semantic_error(msg + "Linija:" + line);
    }

    // Overrideovana MJParser funkcija.
    //
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    // Sa vezbi funkcija.
    //
    public void report_error(String message, Object info) {
        errorDetected = true;
        StringBuilder msg = new StringBuilder(message);
        if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
        StringBuilder msg = new StringBuilder(message);
        if (info instanceof Symbol)
        {
            Symbol symbol = (Symbol)info;
            msg.append(symbol.toString()).append (" na liniji ").append(symbol.left);
        }
        log.info(msg.toString());
    }


    boolean find_double_and_report_search(String name, int line, String additionalMessage)
    {
        Scope currentScope = Tab.currentScope;

        Obj objDoubleDef = currentScope.findSymbol(name);
        // Nadjen je duplikat u okruzujucem opsegu.
        //
        if (objDoubleDef != null)
        {
            additionalMessage += " simbol " + name +  " vec postoji.";
            semantic_error(additionalMessage, line);
            return true;
        }
        else
        {
            return false;
        }
    }

    boolean check_type_and_report(Obj obj, Struct type, int line, String additionalMessage)
    {
        if (!obj.getType().equals(type) && ( additionalMessage != null) ){
            semantic_error(additionalMessage + ". Tipovi nisu kompatibilni.", line);
            return false;
        }
        return true;
    }

    ObjResultWrapper find_for_use_and_report(String name, int line, String additionalMessage)
    {
        ObjResultWrapper result = null;
        Obj obj = Tab.find(name);
        result = new ObjResultWrapper(obj, obj.getKind() == Obj.Con);
        if (obj == Tab.noObj)
        {
            semantic_error(additionalMessage + " Nije definisan u okruzujucem opsegu.", line);
            result.setSemanticError(true);
        }
        else
        {
            // TODO : info za koriscenje objekta
        }

        return result;
    }



    void pushOnCodeStack(LinkedList<LinkedList<Byte>> codeStack, int beginAddress)
    {
        // Oprezno, mozda je jos neophodno azurirati!!!
        //
        LinkedList<Byte> listOfCode = new LinkedList<Byte>();

        for (int idx = beginAddress; idx < Code.pc; idx ++)
        {
            listOfCode.addLast(Code.buf[idx]);
        }
        codeStack.addLast(listOfCode);
        Code.pc = beginAddress;
    }

    void popFromCodeStack(LinkedList<LinkedList<Byte>> codeStack)
    {
        LinkedList<Byte> listOfCode = codeStack.removeLast();
        for (int idx = 0; idx < listOfCode.size(); idx ++)
        {
            Code.put(listOfCode.get(idx));
        }
    }

    void updateAdresses(LinkedList<LinkedList<Integer>> list)
    {
        LinkedList<Integer> listOfJumpAdresses = list.removeLast();

        for (int idx = 0; idx < listOfJumpAdresses.size(); idx ++)
        {
            Code.fixup(listOfJumpAdresses.get(idx));
        }
    }

    void putIntInStaticData(int val)
    {
        Code.loadConst(val);
        Code.put(Code.putstatic);
        Code.put2(TabExt.staticDataCnt++);
    }

    boolean isMethodStatic(Obj obj)
    {
        return obj.getFpPos() != 0;
    }

    void setMethodStatic(Obj obj)
    {
        obj.setFpPos(1);
    }

    void initVirtualFunctionTable(Obj objType, LinkedList<Integer> listVFTAdresses)
    {
        Struct type = objType.getType();
        Collection<Obj> symbols = type.getMembers();
        if (listVFTAdresses.size() > 0)
        {
            Code.fixup(listVFTAdresses.getLast());
        }

        objType.setAdr(TabExt.staticDataCnt);
        for (Obj obj : symbols)
        {
            if ( (obj.getKind() == Obj.Meth) && !isMethodStatic(obj))
            {
                String name = obj.getName();
                for (int idx = 0; idx < name.length(); idx ++)
                {
                    putIntInStaticData((int)name.charAt(idx));
                }
                putIntInStaticData(-1);
                putIntInStaticData(obj.getAdr());
            }
        }
        putIntInStaticData(-2);

        Code.putJump(0);
        listVFTAdresses.addLast(Code.pc - 2);
    }

:}

action code {:
    final String METHOD_ENTRY_NAME = "main";
    final String VFT_POINTER_NAME = "_vftPointer";
    final int OP_ASSIGN_CODE = 0;
    final int CHAR_SIZE = 1;
    final int INT_SIZE = 4;
    ObjResultWrapper curConstType = null;
    ObjResultWrapper curVarType = null ;
    ObjResultWrapper curLocalType = null;
    ObjResultWrapper curFormType = null;
    ObjResultWrapper curFieldType = null;
    ObjResultWrapper curObjWrappFieldOrElem = null;
    ObjResultWrapper curObjWrapperClass = null;
    LinkedList<ObjResultWrapper> listCurObjWrapperFieldOrElem = new LinkedList<ObjResultWrapper>();
    LinkedList<Integer> listAdrIfConditionTrue = new LinkedList<Integer>();
    LinkedList<Integer> listAdrIfConditionFalse = new LinkedList<Integer>();

    LinkedList<Integer> listAdrForConditionFalse  = new LinkedList<Integer>();
    LinkedList<Integer> listAdrForCondition = new LinkedList<Integer>();
    LinkedList<LinkedList<Byte>> listSavedCode = new LinkedList<LinkedList<Byte>>();
    LinkedList<LinkedList<Integer>> listOfListOfBreaksInFor = new LinkedList<LinkedList<Integer>>();
    LinkedList<LinkedList<Integer>> listOfListOfContinuesInFor = new LinkedList<LinkedList<Integer>>();
    LinkedList<Integer> listVFTAdresses = new LinkedList<Integer>();
    Integer forLastDesigantorBeginAddress = null;


    boolean globalVar = false;
    boolean localVar = false;
    boolean formVar = false;
    boolean fieldVar = false;
    boolean isInClass = false;
    boolean addThis = false;
    int formParCnt = 0;

:}

scan with {:
    Symbol s = this.getScanner().next_token();
    if (s != null && s.value != null)
        log.debug(s.toString() + " " + s.value.toString());
    return s;
:}


init with {:
    Tab.init(); // Universe scope
:}


terminal PROGRAM, STATIC, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, FOR, EXTENDS, CONTINUE;
terminal String IDENT;
terminal Integer CONST_NUM;
terminal String CONST_CHAR;
terminal String CONST_BOOL;
terminal OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_MOD, OP_EQ, OP_NOT_EQ, OP_GREAT, OP_LESS, OP_GTE, OP_LTE;
terminal OP_AND, OP_OR, OP_ASSIGN, OP_ASSIGN_ADD, OP_ASSIGN_SUB, OP_ASSIGN_MUL, OP_ASSIGN_DIV, OP_ASSIGN_MOD;
terminal OP_INC, OP_DEC, SEMI_COLUMN, COMMA, DOT, PAR_LEFT, PAR_RIGHT;
terminal BRACKET_LEFT, BRACKET_RIGHT, BRACE_LEFT, BRACE_RIGHT;

non terminal Program;
non terminal GlobalDeclListEpsilon, GlobalDeclList, GlobalDecl, GlobalVarDecl, MethodDeclListEpsilon, MethodDeclList;

non terminal ConstDecl, ConstExprList, ConstExpr;
non terminal Obj ConstNum;
non terminal Obj ConstChar;
non terminal Obj ConstBool;
non terminal Obj ConstValue;
non terminal ObjResultWrapper VarExpr;
non terminal GlobalVarExprList, GlobalVarExprCommaList;
non terminal ObjResultWrapper VarExprOrErrorSemi;
non terminal ObjResultWrapper VarExprOrErrorComma;
non terminal Boolean BracketEpsilon;
non terminal ClassDecl, ExtendsTypeEpsilon, FieldDeclListEpsilon, FieldDeclList, FieldDecl, FieldExprList, BraceMethodDeclListEpsilonEpsilon;

non terminal MethodDecl;
non terminal Boolean StaticEpsilon;
non terminal  ObjResultWrapper ReturnType;
non terminal  LocalVarDeclListBraceLeftEpsilon, LocalVarDeclListBraceLeft, LocalVarDeclOrErrorSemi, LocalVarDeclListOrErrorSemi, LocalVarExprList, LocalVarDeclOrErrorBraceLeft, StatementListEpsilon, StatementList;
non terminal FormPars, FormPar, FormParsEpsilonParRight, FormParOrErrorComma, FormParsParRight, FormParOrErrorParRight;
non terminal ObjResultWrapper Type;
non terminal Statement, ElseStatementEpsilon, ExprEpsilon, IfConditionParRight;
non terminal Obj CommaConstNumEpsilon;
non terminal DesignatorStatement, ActParsEpsilon, ActPars, CommaExprListEpsilon, CommaExprList, CommaExpr, DesignatorStatementOrAssignErrorSemi, DesignatorStatementOrAssignOrErrorSemi, ForConditionSemi, DesignatorStatementOrAssignOrErrorParRight, AssingmentStatement, DesignatorStatementOrAssign, AssingmentStatementOrErrorSemi;
non terminal ObjResultWrapper DesignatorIncOrDec;
non terminal ObjResultWrapper DesignatorFuncCall;
non terminal Integer IncOrDec;
non terminal ObjResultWrapper ExpOrErrorSemi;
non terminal ObjResultWrapper AssignOpExpOrErrorSemi;
non terminal ForCondition;
non terminal ObjResultWrapper OpOrCondTermList;
non terminal ObjResultWrapper CondTerm;
non terminal ObjResultWrapper OpAndCondFactList;
non terminal ObjResultWrapper CondFact;
non terminal ObjResultWrapper RelOpExprOrEpsilon;
non terminal ObjResultWrapper Expr;
non terminal Boolean OpSubEpsilon;
non terminal ObjResultWrapper AddopRightTerm;
non terminal ObjResultWrapper AddopLeftTerm;
non terminal ObjResultWrapper Term;
non terminal ObjResultWrapper MullopRightFactor;
non terminal ObjResultWrapper  MulopLeftFactor;
non terminal ObjResultWrapper Factor;
non terminal ParActParsEpsilonEpsilon;
non terminal ObjResultWrapper BracketExprEpsilon;
non terminal ObjResultWrapper Designator;
non terminal ObjResultWrapper DotIdentOrBracketExprListEpsilon;
non terminal ObjResultWrapper DotIdentOrBracketExprList;
non terminal ObjResultWrapper DotIdentOrBracketExpr;
non terminal Integer Assignop;
non terminal Integer Relop;
non terminal Integer AddopLeft;
non terminal Integer AddopRight;
non terminal Integer MulopLeft;
non terminal Integer MulopRight;


precedence left ELSE;

/************************* PROGRAM **************************/
/************************************************************/
Program ::=
    {:
        parser.report_info("Krece da prepoznaje globalne deklaracije", null);
    :}
    PROGRAM
    IDENT : programName
    {:

        Tab.insert(Obj.Type, "bool", TabExt.boolType);

        Obj eolObj = Tab.find("eol");
        eolObj.setAdr((int)'\n');

        Obj chrObj = Tab.find("chr");
        chrObj.setAdr(Code.pc);
        Code.put(Code.enter);
        Code.put(1);
        Code.put(1);
        // Read variable from procedure stack and leave it as return value.
        Code.put(Code.load_n);
        Code.put(Code.exit);
        Code.put(Code.return_);

        Obj ordObj = Tab.find("ord");
        ordObj.setAdr(Code.pc);
        Code.put(Code.enter);
        Code.put(1);
        Code.put(1);
        Code.put(Code.load_n);
        Code.put(Code.exit);
        Code.put(Code.return_);

        Obj lenObj = Tab.find("len");
        lenObj.setAdr(Code.pc);
        Code.put(Code.enter);
        Code.put(1);
        Code.put(1);
        Code.put(Code.load_n);
        Code.put(Code.arraylength);
        Code.put(Code.exit);
        Code.put(Code.return_);


        TabExt.programObj = Tab.insert(Obj.Prog, programName, Tab.noType);

        Tab.openScope();
    :}
    GlobalDeclListEpsilon
    BRACE_LEFT
    MethodDeclListEpsilon
    BRACE_RIGHT
    {:

        // TODO update with virtual table.
        //
        Code.dataSize = TabExt.staticDataCnt;
        Tab.chainLocalSymbols(TabExt.programObj);
        Tab.closeScope();

        if (!TabExt.doesMainExist)
        {
            semantic_error("Ne postoji globalna main funkcija");
        }

        parser.report_info("****************** NIVO A***********************", null);
        parser.report_info("Broj definicija globalnih promenljivih " + ParserCnt.globalVarDefCnt, null);
        parser.report_info("Broj definicija lokalnih promenljivih u main funkciji " + ParserCnt.localVarDefMainCnt, null);
        parser.report_info("Broj definicija globalnih konstanti " + ParserCnt.globalConstDefCnt, null);
        parser.report_info("Broj deklaracija globalnih nizova " + ParserCnt.globalArrayDeclCnt, null);
        parser.report_info("******************* NIVO B**********************", null);
        parser.report_info("Broj definicija globalnih i statickih funkcija unutrasnjih klasa " + ParserCnt.globalAndStaticMethodCnt, null);
        parser.report_info("USPESNO PREPOZNAVANJE", null);
        Tab.dump(TabExt.symbolTableVisitor);

        if (errorDetected)  {
            parser.report_error("Neuspesno parsiranje!!!", null);
        }
        else {
            parser.report_info("Uspesno parsiranje!!!", null);
            File f = new File(fileName);
            if (f.exists())
            {
                f.delete();
            }
            f = new File(fileName);
            Code.write(new FileOutputStream(f));

        }
    :}
    ;

GlobalDeclListEpsilon ::=
    GlobalDeclList
	|
	/* epsilon */
	;

GlobalDeclList ::=
    GlobalDeclList GlobalDecl
    |
    GlobalDecl
    ;

GlobalDecl ::=
    ConstDecl
	|
    // Samo zbog oporavka od greske.
    //
	GlobalVarDecl
	|
	ClassDecl
    {:
        parser.log.debug("Prepoznata klasa", null);
    :}
    ;


GlobalVarDecl ::=
    Type:varType
    {:
        curVarType = varType;
        globalVar = true;
    :}
    GlobalVarExprList
    {:
        globalVar = false;
    :}
    ;
GlobalVarExprList ::=
    GlobalVarExprCommaList VarExprOrErrorSemi
    |
    VarExprOrErrorSemi:exprOrError
    {:
        RESULT = exprOrError;
    :}
    ;

VarExprOrErrorSemi ::=
    VarExpr:t
    SEMI_COLUMN
    {:
        RESULT = (new ObjResultWrapper());
    :}
    |
    error:text SEMI_COLUMN
    {:
        RESULT = (new ObjResultWrapper()).setSyntaxError(true);

        parser.report_error("Uspesan oporavak od greske deklaracije globalne promenljive,  SEMI_COLUMN je resio stvar" , null);
    :}
    ;

GlobalVarExprCommaList ::=
    GlobalVarExprCommaList VarExprOrErrorComma
    |
    VarExprOrErrorComma:exprOrError
    {:
        RESULT = exprOrError;
    :}
    ;
VarExprOrErrorComma ::=
    VarExpr:t
    COMMA
    {:
        RESULT  = t;
    :}
    |
    error COMMA
    {:
        RESULT = (new ObjResultWrapper()).setSyntaxError(true);
        parser.report_error("Uspesan oporavak od greske prilikom deklaracije globalne promenljiva COMMA je resila stvar", null);
    :}
    ;



MethodDeclListEpsilon ::=
    MethodDeclList
	|
	/* epsilon */
	;

MethodDeclList ::=
    MethodDeclList MethodDecl
    |
    MethodDecl
    ;

/************************* ConstDecl ************************/
/************************************************************/
ConstDecl ::=
    CONST Type:type
    {:
        curConstType = type;
    :}
    ConstExprList
    {:

    :}SEMI_COLUMN
    ;

ConstExprList ::=
    ConstExprList COMMA ConstExpr
    |
    ConstExpr
    ;

ConstExpr ::=
    IDENT:nameOfConst OP_ASSIGN ConstValue:numObj
    {:
        // Da li se konstanta slaze po tipu sa deklaracijom.
        //
        if (!curConstType.isSemanticError()
            &&(check_type_and_report(numObj, curConstType.getObj().getType(), numObj.getLevel(), " poredjenje tipova konstanti")))
        {
            // Da nema slucajno duplikata.
            //
            if (!find_double_and_report_search(nameOfConst, nameOfConstleft, "Konstanta"))
            {
                Obj constObj = Tab.insert(Obj.Con, nameOfConst, curConstType.getObj().getType());
                constObj.setAdr(numObj.getAdr());
            }

        }

    :}
    ;



ConstValue ::=
        ConstNum:constNum
        {:
            RESULT = constNum;
        :}
        |
        ConstBool:constBool
        {:
            RESULT = constBool;
        :}
        |
        ConstChar:constChar
        {:
            RESULT = constChar;
        :}
        ;

ConstNum ::=
        CONST_NUM:number
        {:
            RESULT = new Obj(Obj.Con, number.toString(), Tab.intType, number.intValue(), numberleft);
        :}
        ;

ConstBool ::=
        CONST_BOOL:boolStr
        {:
            RESULT = new Obj(Obj.Con, "", TabExt.boolType, Boolean.valueOf(boolStr) ? 1 : 0, boolStrleft);
        :}
        ;

ConstChar ::=
        CONST_CHAR : charStr
        {:
            char c = charStr.charAt(1);
            RESULT = new Obj(Obj.Con, "", Tab.charType,
            c, charStrleft);

        :}
        ;

/************************* VarDecl **************************/
/************************************************************/



VarExpr ::=
    IDENT:nameOfVar
    BracketEpsilon:isArray
    {:
        {
            Struct typeVar = null;
            String message = "";
            Obj varObj = null;
            int objType = Obj.Var;


            if (globalVar)
            {
                message = "Definicija globalne varijable";
                if (!curVarType.isSemanticError())
                {
                    typeVar = curVarType.getObj().getType();
                }

            }
            else if (localVar)
            {
                message = "Definicija lokalne varijable";
                if (!curLocalType.isSemanticError())
                {
                    typeVar = curLocalType.getObj().getType();
                }
            }
            else if (formVar)
            {
                message = "Definicija formalnog parametra";
                if (!curFormType.isSemanticError())
                {
                    typeVar = curFormType.getObj().getType();
                }
            }
            else if (fieldVar)
            {
                message = "Definicija polja klase";
                if (!curFieldType.isSemanticError())
                {
                    typeVar = curFieldType.getObj().getType();
                    objType = Obj.Fld;
                }
            }

            if (isArray)
            {
                if (typeVar != null)
                {
                    typeVar = new Struct (Struct.Array, typeVar);
                }
            }

            if (!find_double_and_report_search(nameOfVar, nameOfVarleft, message)
                && (typeVar != null) )
            {

                varObj = Tab.insert(objType, nameOfVar, typeVar);
                if (formVar)
                {
                    varObj.setAdr(Tab.currentScope().getnVars() - 1);
                    // TODO : think about formPar
                    //
                }
                else if (globalVar)
                {
                    varObj.setAdr(TabExt.staticDataCnt++);
                }
            }
            else
            {
                RESULT = (new ObjResultWrapper()).setSemanticError(true);
            }
        }

    :}
    ;

BracketEpsilon ::=
    BRACKET_LEFT
    BRACKET_RIGHT
    {:
        RESULT = true;
    :}
    |
    {:
        RESULT = false;
    :}
    ;


/************************* ClassDecl **************************/
/************************************************************/
ClassDecl ::=
    CLASS
    IDENT:nameOfClass
    {:
        isInClass = true;
        // TODO : add double check
        if (find_double_and_report_search(nameOfClass, nameOfClassleft, "Ime je vec deklarisano u okruzujucem opsegu"))
        {
            // TODO : test
            curObjWrapperClass = (new ObjResultWrapper()).setSemanticError(true);
            curObjWrapperClass.setSemanticError(true);
        }
        else
        {
            Obj obj = Tab.insert(Obj.Type, nameOfClass, new Struct(Struct.Class));
            curObjWrapperClass = new ObjResultWrapper(obj, false);
        }
    :}
	ExtendsTypeEpsilon
    {:
        // TODO extending
    :}
	BRACE_LEFT
    {:
        // TODO : add check for existance.
        //
        Tab.openScope();
        //initVirtualFunctionTablePointer();
        Tab.insert(Obj.Fld, VFT_POINTER_NAME, Tab.intType);

    :}
	FieldDeclListEpsilon
    {:

        // TODO : add check of semantic error.
    :}
    BraceMethodDeclListEpsilonEpsilon
    {:
        // TODO : check of semantic error


    :}

	BRACE_RIGHT
    {:
        Tab.chainLocalSymbols(curObjWrapperClass.getObj().getType());
        Tab.closeScope();
        Tab.insert(Obj.Type, curObjWrapperClass.getObj().getName(), curObjWrapperClass.getObj().getType());

        if (listVFTAdresses.size() == 0)
        {
            Code.mainPc = Code.pc;
        }
        initVirtualFunctionTable(curObjWrapperClass.getObj(), listVFTAdresses);

        isInClass = false;
        parser.log.debug("Prepoznata klasa", null);
    :}
    ;

ExtendsTypeEpsilon ::=
            EXTENDS Type
            |
            /* epsilon */
            ;

FieldDeclListEpsilon ::=
            FieldDeclList
            |
            /* epsilon */
            ;
FieldDeclList ::=
            FieldDeclList FieldDecl
            |
            FieldDecl
            ;


FieldDecl ::=
    Type:type
    {:
        curFieldType = type;
        fieldVar = true;
    :}
    FieldExprList SEMI_COLUMN
    {:
        fieldVar = false;
    :}
    ;
FieldExprList ::=
            FieldExprList COMMA VarExpr
            |
            VarExpr
            ;

BraceMethodDeclListEpsilonEpsilon ::=
            BRACE_LEFT MethodDeclListEpsilon BRACE_RIGHT
            |
            /* epsilon */
            ;

/************************* MethodDecl **************************/
/************************************************************/
MethodDecl ::=
        StaticEpsilon:isStatic
        {:
            if (!isInClass)
            {
                // TODO add semantic error for static in global function
            }
            else
            {
                if (!isStatic)
                {
                    addThis = true;
                }
            }
        :}

        ReturnType:retType
        {:
            parser.log.debug("Prepoznat povratni tip", null);
        :}
        IDENT:nameOfMethod
        {:
            String message = "Metoda";
            if (!find_double_and_report_search(nameOfMethod, nameOfMethodleft, message))
            {
                TabExt.curMethod  = Tab.insert(Obj.Meth, nameOfMethod, retType.getObj().getType());
            }

        :}
        PAR_LEFT
        {:
            Tab.openScope();
            if (addThis)
            {
                Obj varObj = Tab.insert(Obj.Var, "this", curObjWrapperClass.getObj().getType());
                varObj.setAdr(0);
                addThis = false;

            }
            else
            {
                setMethodStatic(TabExt.curMethod);
            }

        :}
        FormParsEpsilonParRight
        {:
            if (null != TabExt.curMethod)
            {
                // Postavi broj formalnih parametara.
                //
                TabExt.curMethod.setLevel(Tab.currentScope().getnVars());
            }
        :}
        LocalVarDeclListBraceLeftEpsilon
        {:
            if (null != TabExt.curMethod)
            {
                Tab.chainLocalSymbols(TabExt.curMethod);
            }
            // TODO : Sumnjivo mi ovo nesto, mozda ranije treba (da bi se spremio stek)
            //
            TabExt.curMethod.setAdr(Code.pc);
            if (nameOfMethod.equals(METHOD_ENTRY_NAME))
            {
                TabExt.doesMainExist = true;
                if (listVFTAdresses.size() == 0)
                {
                    Code.mainPc = TabExt.curMethod.getAdr();
                }
                else
                {
                    Code.fixup(listVFTAdresses.getLast());
                }

            }

            Code.put(Code.enter);
            Code.put(TabExt.curMethod.getLevel());
            Code.put(Tab.currentScope().getnVars());

            parser.log.debug("Zavrseno prepoznavanje deklaracija lokalnih promen", null);
        :}
        StatementListEpsilon
        BRACE_RIGHT
        {:
            // Dealocira se stek.
            //
            if (retType.getObj().getType() == Tab.noType)
            {
                Code.put(Code.exit);
                Code.put(Code.return_);
            }
            else
            {
                // Error in case of no return.
                //
                Code.put(Code.trap);
                Code.put(1);
            }

            Tab.closeScope();
            parser.log.debug("Prepoznat METHOD", null);
        :}
        ;
StaticEpsilon ::=
            STATIC
            {:
                RESULT = new Boolean(true);
            :}

            |
            /*epsilon*/
            {:
                RESULT = new Boolean(false);
            :}
            ;
ReturnType ::=
            Type:type
            {:
                RESULT = type;
            :}
            |
            VOID
            {:
                RESULT = new ObjResultWrapper(new Obj(Obj.Type, "", Tab.noType), false);
            :}
            ;
FormParsEpsilonParRight ::=
            FormParsParRight
            |
            PAR_RIGHT
            ;
LocalVarDeclListBraceLeftEpsilon ::=
            LocalVarDeclListBraceLeft
            |
            BRACE_LEFT
            ;

LocalVarDeclListBraceLeft ::=
            LocalVarDeclListOrErrorSemi LocalVarDeclOrErrorBraceLeft
            |
            LocalVarDeclOrErrorBraceLeft
            ;

LocalVarDeclListOrErrorSemi ::=
            LocalVarDeclListOrErrorSemi LocalVarDeclOrErrorSemi
            |
            LocalVarDeclOrErrorSemi
            ;

LocalVarDeclOrErrorSemi ::=
            Type:type
            {:
                curLocalType =  type;
                localVar = true;
            :}
            LocalVarExprList SEMI_COLUMN
            {:
                localVar = false;
            :}
            |
            error:text SEMI_COLUMN
            {:
              parser.report_error("Uspesan oporavak od greske deklaracije lokalne promenljive,  SEMI_COLUMN je resio stvar" , null);
            :}
            ;
LocalVarExprList ::=
            LocalVarExprList COMMA VarExpr
            |
            VarExpr
            ;

LocalVarDeclOrErrorBraceLeft ::=
            error:text BRACE_LEFT
            {:
                  parser.report_error("Uspesan oporavak od greske deklaracije lokalne promenljive,  BRACE_LEFT je resila stvar" , null);
            :}
            |
            LocalVarDeclOrErrorSemi BRACE_LEFT
            ;

StatementListEpsilon ::=
            StatementList
            |
            /* epsilon */
            ;
StatementList ::=
            StatementList Statement
            |
            Statement
            ;

/************************* FormPars **************************/
/************************************************************/
FormParsParRight ::=
            FormPars FormParOrErrorParRight
            |
            FormParOrErrorParRight
            ;

FormPars ::=
            FormPars FormParOrErrorComma
            |
            FormParOrErrorComma
            ;

FormParOrErrorComma ::=
            FormPar COMMA
            |
            error COMMA
            {:
                  parser.report_error("Uspesan oporavak od greske deklaracije formalnog parametra lokalne funkcije,  COMMA je resila stvar" , null);
            :}
            ;

FormParOrErrorParRight ::=
            FormPar PAR_RIGHT
            |
            error PAR_RIGHT
            {:
                  parser.report_error("Uspesan oporavak od greske deklaracije formalnog parametra lokalne funkcije,  PAR_RIGHT je resio stvar" , null);
            :}
            ;

FormPar::=
            Type:type
            {:
                curFormType = type;
                formVar = true;
            :}
            VarExpr
            {:
                formVar = false;
            :}
            ;




/************************* Type **************************/
/************************************************************/
Type ::=
        IDENT:nameOfType
        {:
            Obj obj = Tab.find(nameOfType);
            if (obj.getKind() != Obj.Type)
            {
                obj = new Obj(Obj.Type, "", Tab.noType);
                semantic_error("Nije definisan tip:" + nameOfType+" ", nameOfTypeleft);
                RESULT = (new ObjResultWrapper(obj, false)).setSemanticError(true);
            }
            else
            {
                RESULT = (new ObjResultWrapper(obj, false));
            }
        :}
        ;


/************************* Statement **************************/
/************************************************************/

Statement ::=
        DesignatorStatementOrAssignErrorSemi
        {:
            parser.log.debug("Prepoznata STATEMENT", null);
        :}
        |
        // TODO : add check for type of expression.
        //
        IF PAR_LEFT IfConditionParRight
        {:
            // FALSE.
            //
            Code.put(Code.const_n);
            Code.putFalseJump(Code.ne, 0);
            int adrConditionFalse = Code.pc - 2;
            listAdrIfConditionFalse.addLast(adrConditionFalse);
        :}
        Statement
        {:

            Code.putJump(0);
            Code.fixup(listAdrIfConditionFalse.removeLast());
            int adrConditionTrue = Code.pc - 2;
            listAdrIfConditionTrue.addLast(adrConditionTrue);
        :}
        ElseStatementEpsilon
        {:

            Code.fixup(listAdrIfConditionTrue.removeLast());
            parser.log.debug("Prepoznat IF", null);
        :}
        |
        FOR PAR_LEFT DesignatorStatementOrAssign SEMI_COLUMN
        {:
            listAdrForCondition.addLast(Code.pc);
        :}
        ForConditionSemi
        {:
            Code.put(Code.const_n);
            Code.putFalseJump(Code.ne, 0);
            int adrConditionFalse = Code.pc - 2;
            listAdrForConditionFalse.addLast(adrConditionFalse);


            forLastDesigantorBeginAddress = Code.pc;
        :}
        DesignatorStatementOrAssignOrErrorParRight
        {:
            pushOnCodeStack(listSavedCode, forLastDesigantorBeginAddress);
            listOfListOfContinuesInFor.addLast(new LinkedList<Integer>());
            listOfListOfBreaksInFor.addLast(new LinkedList<Integer>());
        :}



        Statement
        {:
            updateAdresses(listOfListOfContinuesInFor);
            popFromCodeStack(listSavedCode);

            int adrCondition = listAdrForCondition.removeLast();
            Code.putJump(adrCondition);

            updateAdresses(listOfListOfBreaksInFor);
            Code.fixup(listAdrForConditionFalse.removeLast());
        :}
        |
        FOR error SEMI_COLUMN ForCondition SEMI_COLUMN DesignatorStatementOrAssign PAR_RIGHT
        |
        FOR DesignatorStatementOrAssign SEMI_COLUMN error SEMI_COLUMN DesignatorStatementOrAssign PAR_RIGHT
        |
        FOR DesignatorStatementOrAssign SEMI_COLUMN ForCondition SEMI_COLUMN error PAR_RIGHT
        |
        FOR error SEMI_COLUMN error SEMI_COLUMN DesignatorStatementOrAssign PAR_RIGHT
        |
        FOR error SEMI_COLUMN ForCondition SEMI_COLUMN error PAR_RIGHT
        |
        FOR DesignatorStatementOrAssign SEMI_COLUMN error SEMI_COLUMN error PAR_RIGHT
        |
        FOR error SEMI_COLUMN error SEMI_COLUMN error PAR_RIGHT
        |
        FOR error SEMI_COLUMN error PAR_RIGHT
        |
        FOR error PAR_RIGHT
        |
        BREAK SEMI_COLUMN
        {:
            // Ne mora 0. Moze sta god.
            //
            Code.putJump(0);
            int adr = Code.pc - 2;
            listOfListOfBreaksInFor.getLast().addLast(adr);
            parser.log.debug("Prepoznat BREAK", null);
        :}
        |
        CONTINUE SEMI_COLUMN
        {:
            Code.putJump(0);
            int adr = Code.pc - 2;
            listOfListOfContinuesInFor.getLast().addLast(adr);
            parser.log.debug("Prepoznat CONTINUE", null);
        :}
        |
        RETURN ExprEpsilon SEMI_COLUMN
        {:
            // TODO : return check semantic.
            // Should exist, are types ok...
            //
            Code.put(Code.exit);
            Code.put(Code.return_);

            parser.log.debug("Prepoznat RETURN", null);
        :}
        |
        READ PAR_LEFT Designator:des PAR_RIGHT SEMI_COLUMN
        {:
            if (des.isLeftValue() &&
                (des.getObj().getType().equals(Tab.intType)
                || (des.getObj().getType().equals(Tab.charType))
                || (des.getObj().getType().equals(TabExt.boolType))))
            {
                Code.put(Code.pop);
                if (des.getObj().getType().equals(Tab.charType))
                {
                    Code.put(Code.bread);
                }
                else
                {
                    Code.put(Code.read);
                }
                Code.store(des.getObj());
            }
            else
            {

            }
            parser.log.debug("Prepoznat READ", null);
        :}
        |
        PRINT PAR_LEFT Expr:expr CommaConstNumEpsilon:numObj PAR_RIGHT SEMI_COLUMN
        {:
            Struct typeExpr = expr.getObj().getType();
            if (typeExpr.equals(TabExt.boolType)
                || typeExpr.equals(Tab.intType)
                || typeExpr.equals(Tab.charType))
                {
                    // Da li ima dodatnog parametra.
                    //
                    if (!numObj.getType().equals(Tab.noType))
                    {
                        Code.load(numObj);
                    }
                    else
                    {
                        Code.loadConst(0);
                    }
                    if (typeExpr.equals(Tab.charType))
                    {
                        Code.put(Code.bprint);
                    }
                    else
                    {
                        Code.put(Code.print);
                    }

                    if (expr.isArrayElement())
                    {
                        Code.put(Code.pop);
                        Code.put(Code.pop);
                    }
                    else if (expr.isField())
                    {
                        Code.put(Code.pop);
                    }
                }
                else
                {
                    expr.setSemanticError(true);
                }
            RESULT = expr;
            parser.log.debug("Prepoznat PRINT");
        :}
        |
        BRACE_LEFT StatementListEpsilon BRACE_RIGHT
        {:
            parser.log.debug("Prepoznat BLOK", null);
        :}
        ;

ElseStatementEpsilon ::=
        ELSE
        Statement

        {:
            parser.log.debug("Prepoznat ELSE", null);
        :}
        |
        /* epsilon */
        ;

ExprEpsilon ::=
        Expr
        |
        /* epsilon */
        ;



ForConditionSemi ::=
        ForCondition SEMI_COLUMN
        |
        SEMI_COLUMN
        |
        error SEMI_COLUMN
        {:
              parser.report_error("Uspesan oporavak od greske kod uslova u for-u,  SEMI_COLUMN je resio stvar" , null);
        :}
        ;

CommaConstNumEpsilon ::=
        COMMA CONST_NUM:number
        {:
            RESULT = new Obj(Obj.Con, number.toString(), Tab.intType, number.intValue(), numberleft);
        :}
        |
        {:
            RESULT = new Obj(Obj.Con, "", Tab.noType);
        :}
        ;

/* ovde moze biti igranja */
/******************* Designator Statement *******************/
/************************************************************/


DesignatorStatementOrAssign ::=

            DesignatorStatement
            |
            AssingmentStatement
            |
            /* epsilon */
            ;

DesignatorStatementOrAssignOrErrorParRight ::=
            DesignatorStatement PAR_RIGHT
            |
            AssingmentStatement PAR_RIGHT
            |
            PAR_RIGHT
            |
            error PAR_RIGHT
            {:
                  parser.report_error("Uspesan oporavak od greske kod inkrementatorra u for-u,  PAR_RIGHT je resio stvar" , null);
            :}
            ;

DesignatorStatementOrAssignErrorSemi ::=
        DesignatorStatement SEMI_COLUMN
        |
        AssingmentStatementOrErrorSemi:expr
        {:
            RESULT = expr;
        :}
        ;


DesignatorStatement ::=
        DesignatorIncOrDec:incOrDec
        {:
            RESULT = incOrDec;
        :}
        |
        DesignatorFuncCall:funcCall
        {:
            if (funcCall.getObj().getType() != Tab.noType)
            {
                Code.put(Code.pop);
            }
            RESULT = funcCall;
        :}
        ;

DesignatorIncOrDec ::=
        Designator:designator IncOrDec:op
        {:

            if (!designator.isSemanticError() &&
                designator.isLeftValue() && designator.getObj().getType().equals(Tab.intType))
                {
                    // right value is not needed
                    // because a i a[i] is good because there is no inc
                    Code.loadConst(1);
                    Code.put(op);
                    Code.store(designator.getObj());
                    designator.setRightValue(true);
                }
                else
                {
                    RESULT = designator.setSemanticError(true);
                }
        :}
        ;

IncOrDec ::=
    OP_INC
    {:
        RESULT = Code.add;
    :}
    |
    OP_DEC
    {:
        RESULT = Code.sub;
    :}
    ;

DesignatorFuncCall ::=
        Designator:func
        PAR_LEFT ActParsEpsilon PAR_RIGHT
        {:
            if (func.isVirtual())
            {
                String funcName = func.getObj().getName();
                // VFT_POINTER
                Code.put(Code.getfield);
                Code.put2(0);
                Code.put(Code.invokevirtual);
                for (int idx = 0; idx < funcName.length(); idx ++)
                {
                    Code.put4((int)funcName.charAt(idx));
                }
                Code.put4(-1);

            }
            else
            {
                Code.put(Code.call);
                // Because Code.call is put then pc  = pc + 1.
                //
                int adr = func.getObj().getAdr() - Code.pc + 1;
                Code.put2(adr);
            }
            RESULT = func;
        :}
        ;

ActParsEpsilon ::=
        ActPars
        |
        /* epsilon */
        ;

AssingmentStatement ::=
        Designator:dest
        Assignop:op
        {:
            if (dest.isSemanticError() || !dest.isLeftValue())
            {
                RESULT = dest.setSemanticError(true);
            }
            else
            {
                if (dest.hasAdditionalParsOnStack() && op == OP_ASSIGN_CODE)
                {
                    // a i a[i]
                    Code.put(Code.pop);
                    // a i
                }
            }
        :}
        Expr : expr
        {:
            // Check error.
            //
            if (!dest.isSemanticError() && dest.isLeftValue() &&
                !expr.isSemanticError())
            {
                expr.generateRightValue();
                /*
                if (expr.isArrayElement())
                {
                        // a i a[i]
                    Code.put(Code.dup_x2);
                    // a[i] a i a[i]
                    Code.put(Code.pop);
                    // a[i] a i
                    Code.put(Code.pop);
                    // a[i] a
                    Code.put(Code.pop);
                    // a[i]
                }
                */

                if (op != OP_ASSIGN_CODE)
                {
                    // Vrednost na steku nije duplirana jer
                    // treba samo da se koristi za izracunavanje
                    // Nista za dalje vrednosti.
                    Code.put(op);
                }
                Code.store(dest.getObj());
                if ( (op == OP_ASSIGN_CODE)
                    && !dest.hasAdditionalParsOnStack())
                {
                    Code.put(Code.pop);
                }
            }
            else
            {
                RESULT = dest.setSemanticError(true);
            }
        :}
        ;

AssingmentStatementOrErrorSemi ::=
        Designator:dest
        Assignop:op
        {:
            if (dest.isSemanticError() || !dest.isLeftValue())
            {
                RESULT = dest.setSemanticError(true);
            }
            else
            {
                if ( dest.hasAdditionalParsOnStack() && op == OP_ASSIGN_CODE)
                {
                    // a i a[i]
                    // c c.x
                    Code.put(Code.pop);
                    // a i
                    // c
                }
            }

        :}
        ExpOrErrorSemi : expr
        {:
            // Check error.
            //
            if (!dest.isSemanticError() && dest.isLeftValue() &&
                (expr != null) &&!expr.isSemanticError())
            {
                expr.generateRightValue();

                if (op != OP_ASSIGN_CODE)
                {
                    // Vrednost na steku nije duplirana jer
                    // treba samo da se koristi za izracunavanje
                    // Nista za dalje vrednosti.
                    Code.put(op);
                }
                Code.store(dest.getObj());
                if ( (op == OP_ASSIGN_CODE)
                    && !dest.hasAdditionalParsOnStack())
                {
                    Code.put(Code.pop);
                }
            }
            else
            {
                RESULT = dest.setSemanticError(true);
            }
        :}
        ;

AssignOpExpOrErrorSemi ::=
        ExpOrErrorSemi:expr
        {:
            RESULT = expr;
        :}
        ;

ExpOrErrorSemi ::=
        Expr:expr SEMI_COLUMN
        {:
            RESULT = expr;
        :}
        |
        error SEMI_COLUMN
        {:

            parser.report_error("Uspesan oporavak od greske dodele promenljive,  SEMI_COLUMN je resio stvar", null);
        :}
        ;

/******************* ActPars  *******************************/
/************************************************************/
ActPars ::=
        Expr:expr
        {:
            expr.generateRightValue();
        :}
        CommaExprListEpsilon
        ;

CommaExprListEpsilon ::=
        CommaExprList
        |
        /* epsilon */
        ;
CommaExprList ::=
        CommaExprList CommaExpr
        |
        CommaExpr
        ;
CommaExpr ::=
        COMMA Expr:expr
        {:
            expr.generateRightValue();
        :}
        ;

/******************* Condition  *****************************/
/************************************************************/
ForCondition ::=
            OpOrCondTermList
            ;
IfConditionParRight ::=
            OpOrCondTermList:cond PAR_RIGHT
            {:
                RESULT = cond;
            :}
            |
            error PAR_RIGHT
            {:
                parser.report_error("Uspesan oporavak od greske prilikom definisanja uslova za if PAR_RIGHT je resila stvar", null);
            :}
            ;
OpOrCondTermList ::=
        OpOrCondTermList OP_OR CondTerm
        // TODO : add checks
        //
        {:
            Code.put(Code.add);
        :}
        |
        CondTerm
        ;

/******************* CondTerm   *****************************/
/************************************************************/
CondTerm ::=
        OpAndCondFactList
        ;
OpAndCondFactList ::=
        OpAndCondFactList:leftFact OP_AND CondFact:rightFact
        // TODO add check if is boolType
        //
        {:
            Code.put(Code.mul);
        :}
        |
        CondFact
        ;

/******************* CondFact   *****************************/
/************************************************************/
CondFact ::=
        Expr:expr
        {:
            if (!expr.isSemanticError())
            {
                expr.generateRightValue();
            }
        :}
        RelOpExprOrEpsilon:compareRight
        {:
            //
            if (!expr.isSemanticError()
                && ( (null == compareRight) || (!compareRight.isSemanticError())))
            {
                if (null == compareRight)
                {
                    if (!expr.getObj().getType().equals(TabExt.boolType))
                    {
                        RESULT = expr.setSemanticError(true);
                    }
                }
                else
                {
                    // TODO: add checks for type compatiblility.
                    //
                    // JCONDFALSE.
                    //
                    Code.putFalseJump(compareRight.getRelOp(), 0);
                    int adrFromWhereToJumpFalse = Code.pc - 2;
                    // TRUE.
                    //
                    Code.put(Code.const_1);
                    Code.putJump(0);
                    int adrFromWhereToJumpTrue = Code.pc - 2;

                    Code.fixup(adrFromWhereToJumpFalse);
                    // False.
                    //
                    Code.put(Code.const_n);
                    // JMP over this
                    Code.fixup(adrFromWhereToJumpTrue);
                }
                RESULT = new ObjResultWrapper(new Obj(Obj.Con, "", TabExt.boolType), true);
            }
            else
            {
                RESULT = expr;
            }


        :}
        ;
RelOpExprOrEpsilon ::=
        Relop:relOp
        Expr:expr
        {:
            if (!expr.isSemanticError())
            {
                expr.generateRightValue();
                expr.setRelOp(relOp);
            }
            RESULT = expr;

        :}
        |
        /* epsilon */
        {:
            RESULT = null;
        :}
        ;


/******************* Expr       *****************************/
/************************************************************/
Expr ::=
    OpSubEpsilon:isNegative
    AddopRightTerm:term
    {:
        if (isNegative)
        {
            if (!term.isSemanticError()
            && check_type_and_report(term.getObj(), Tab.intType, termleft, " Kad se - nalazi ispred nekog izraza, on mora biti int."))
            {
                Code.put(Code.neg);
                term.generateRightValue();
                RESULT = term;
            }
            else
            {
                RESULT = term.setSemanticError(true);
            }
        }
        else
        {
            RESULT = term;
        }

    :}
    ;

OpSubEpsilon ::=
        OP_SUB
        {:
            RESULT = true;
        :}
        |
        {:
            RESULT = false;
        :}
        ;

AddopRightTerm ::=
    AddopLeftTerm:leftTerm AddopRight:op

    AddopRightTerm:rightTerm
    {:
    // Treba dodati provere za polja i sve ostale gluposti
    //
       if (!leftTerm.isSemanticError()
        && !rightTerm.isSemanticError()
        && check_type_and_report(leftTerm.getObj(), Tab.intType, rightTermleft, " Levi sabirak / umanjenik mora biti tipa int.")
        && check_type_and_report(rightTerm.getObj(), Tab.intType, rightTermleft, " Desni sabirak / umanjilac mora biti tipa int."))
        {
            if (leftTerm.isLeftValue())
            {
                rightTerm.generateRightValue();
                Code.put(op);
                if (leftTerm.isArrayElement())
                {
                    // a i sum
                    Code.put(Code.dup_x2);
                    // sum a i sum
                }
                else if (leftTerm.isField())
                {
                    // c sum
                    Code.put(Code.dup_x1);
                    // sum c sum
                }
                else
                {
                    Code.put(Code.dup);
                }
                // sum
                Code.store(leftTerm.getObj());

                leftTerm.setRightValue(true);
                RESULT = leftTerm;
            }
            else
            {
                semantic_error("Kod += -= leva strana treba da bude lvalue");
                RESULT = leftTerm.setSemanticError(true);
            }
        }
        else
        {
            RESULT = leftTerm.setSemanticError(true);
        }
    :}
    |
    AddopLeftTerm:type
    {:
        RESULT = type;
    :}
    ;
AddopLeftTerm ::=
    AddopLeftTerm:leftTerm AddopLeft:op Term:rightTerm
    {:
        if (check_type_and_report(leftTerm.getObj(), Tab.intType, leftTermleft, " Tip levog sabirka/umanjenika u zbiru/proizvodu mora da bude int")
            &&
            check_type_and_report(rightTerm.getObj(), Tab.intType, rightTermleft, " Tip desnog sabirka/umanjioca u zbiru/razlici mora biti int"))
            {
                rightTerm.generateRightValue();
                Code.put(op);
                leftTerm.generateRightValue();
                RESULT = new ObjResultWrapper(new Obj(Obj.Con,"",Tab.intType), true);
        }
        else
        {
            RESULT = leftTerm.setSemanticError(true);
        }
    :}
    |
    Term:term
    {:
        RESULT = term;
    :}
    ;

/**********************   Term       *****************************/
/*****************************************************************/
Term ::=
            MullopRightFactor:rightFactor
            {:
                RESULT = rightFactor;
            :}
            ;

MullopRightFactor ::=
        MulopLeftFactor:leftFactor
        MulopRight:op
        // a i expr -> expr a i expr
        MullopRightFactor:rightFactor
        {:
            // TODO: Treba dodati provere za polja i sve ostale gluposti
            //
            if (!leftFactor.isSemanticError()
            && !rightFactor.isSemanticError()
            && check_type_and_report(leftFactor.getObj(), Tab.intType, leftFactorleft, " Levi cinilac / deljenik mora biti tipa int.")
            && check_type_and_report(rightFactor.getObj(), Tab.intType, rightFactorleft, " Desni cinilac / delilac mora biti tipa int."))
            {
                if (leftFactor.isLeftValue())
                {
                    rightFactor.generateRightValue();
                    Code.put(op);
                    if (leftFactor.isArrayElement())
                    {
                        Code.put(Code.dup_x2);
                    }
                    else if (leftFactor.isField())
                    {
                        Code.put(Code.dup_x1);
                    }
                    else
                    {
                        Code.put(Code.dup);
                    }

                    Code.store(leftFactor.getObj());
                    leftFactor.setRightValue(true);
                    RESULT = leftFactor;
                }
                else
                {
                    semantic_error("Kod /= *= %= leva strana treba da bude lvalue");
                    RESULT = leftFactor.setSemanticError(true);
                }
            }
            else
            {
                RESULT = leftFactor.setSemanticError(true);
            }
        :}
        |
        MulopLeftFactor:factor
        {:
            RESULT = factor;
        :}
        ;

MulopLeftFactor ::=
        MulopLeftFactor:leftFactor
        MulopLeft:op
        Factor:rightFactor
        {:
            if (check_type_and_report(leftFactor.getObj(), Tab.intType, leftFactorleft, " Tip levog cinioca/deljenika u proizvodu mora da bude int")
            &&
                check_type_and_report(rightFactor.getObj(), Tab.intType, rightFactorleft, " Tip desnog cinioca/delioca mora biti int"))
            {
                rightFactor.generateRightValue();
                Code.put(op);
                leftFactor.generateRightValue();
                RESULT = new ObjResultWrapper(new Obj(Obj.Con,"",Tab.intType), true);
            }
            else
            {
                RESULT = leftFactor.setSemanticError(true);
            }
        :}
        |
        Factor:factor
        {:
            RESULT = factor;
        :}
        ;

/**********************   Factor     *****************************/
/*****************************************************************/

Factor ::=
        DesignatorFuncCall:func
        {:
            RESULT = func;
        :}
        |
        Designator:designator
        {:
            RESULT = designator;
        :}
        |
        ConstValue:constValue
        {:
            Code.load(constValue);
            RESULT = new ObjResultWrapper(constValue, true/*isRightValue*/);
        :}
        |
        NEW Type:type BracketExprEpsilon:exprWrap
        {:
            if (null != exprWrap)
            {
                if (!exprWrap.isSemanticError()
                    && !type.isSemanticError()
                    && check_type_and_report(exprWrap.getObj(),
                                          Tab.intType,
                                         exprWrapleft,
                                         "Tip izraza kod NEW operatora sa nizom mora da bude int"))
                {
                    exprWrap.generateRightValue();
                    Code.put(Code.newarray);
                    // TODO: For classes which are non word alligned,
                    // TODO : add
                    // alloc using char
                    //
                    if (type.getObj().getType().equals(Tab.charType))
                    {
                        Code.put(0);
                    }
                    else
                    {
                        Code.put(1);
                    }
                    Struct struct = new Struct(Struct.Array, type.getObj().getType());
                    RESULT = new ObjResultWrapper(new Obj(Obj.Con, "", struct), true);
                }
                else
                {
                    RESULT = (new ObjResultWrapper()).setSemanticError(true);
                }
            }
            else
            {
                if (!type.isSemanticError()
                && (type.getObj().getKind() == Obj.Type)
                && (type.getObj().getType().getKind() == Struct.Class))
                {
                    Code.put(Code.new_);
                    Code.put2(type.getObj().getType().getNumberOfFields() * INT_SIZE);
                    // adr
                    Code.put(Code.dup);
                    // adr adr
                    Code.loadConst(type.getObj().getAdr());
                    // adr adr val
                    // TODO add check if class is not initialized.
                    //
                    Code.store(type.getObj().getType().getMembersTable().searchKey(VFT_POINTER_NAME));
                    RESULT = new ObjResultWrapper(new Obj(Obj.Con, "", type.getObj().getType()), true);
                }
                else
                {
                    RESULT = (new ObjResultWrapper()).setSemanticError(true);
                }

            }
            // TO DO : Add check of errors.
            //
        :}
        |
        PAR_LEFT Expr:result PAR_RIGHT
        {:
            RESULT = result;
        :}
        ;
ParActParsEpsilonEpsilon ::=
            PAR_LEFT ActParsEpsilon PAR_RIGHT
            |
            /* epsilon */
            ;
BracketExprEpsilon ::=
            BRACKET_LEFT Expr:expr BRACKET_RIGHT
            {:
                RESULT = expr;
            :}
            |
            {:
                RESULT = null;
            :}
            /* epsilon */
            ;


/**********************   Designator   ***************************/
/*****************************************************************/
Designator ::=
        IDENT:name
        {:
            // TODO add more checks if is correct.
            curObjWrappFieldOrElem = find_for_use_and_report(name, nameleft, name);


            listCurObjWrapperFieldOrElem.addLast(curObjWrappFieldOrElem);
            if ((!curObjWrappFieldOrElem.isSemanticError())
            && (curObjWrappFieldOrElem.loadable()))
            {
                Code.load(curObjWrappFieldOrElem.getObj());
            }

        :}
        DotIdentOrBracketExprListEpsilon:objWrapper
        {:
            if (!curObjWrappFieldOrElem.isSemanticError())
            {
                if(objWrapper == null)
                {

                    ObjResultWrapper objWrap = new ObjResultWrapper(curObjWrappFieldOrElem.getObj(), curObjWrappFieldOrElem.getObj().getKind() == Obj.Con);
                    RESULT = objWrap;
                }
                else if ( (objWrapper != null) && (!objWrapper.isSemanticError()) )
                {
                    RESULT = objWrapper;
                }
            }
            else
            {
                RESULT = curObjWrappFieldOrElem;
            }

            if (!curObjWrappFieldOrElem.isSemanticError())
            {
                listCurObjWrapperFieldOrElem.removeLast();
                if (listCurObjWrapperFieldOrElem.size() != 0)
                {
                    curObjWrappFieldOrElem = listCurObjWrapperFieldOrElem.getLast();
                }
            }

        :}
            ;
DotIdentOrBracketExprListEpsilon ::=
        DotIdentOrBracketExprList:objWrap
        {:
            RESULT = objWrap;
        :}
        |
        {:
            RESULT = null;
        :}
        /* epsilon */
        ;
DotIdentOrBracketExprList ::=
        DotIdentOrBracketExprList:left DotIdentOrBracketExpr:objWrapper
        {:
            // TODO dodaj proveru da li je levo klasa ili niz (drugo nista ne moze...), i tek onda expandujes to ce ti biti nivo C, do tad ne brini (sledeca nedelja :O )
            if (left.isSemanticError() || objWrapper.isSemanticError())
            {
                RESULT = objWrapper.setSemanticError(true);
            }
            else
            {
                RESULT = objWrapper;
            }

        :}
        |
        DotIdentOrBracketExpr:objWrapper
        {:

            RESULT = objWrapper;
        :}
        ;
DotIdentOrBracketExpr ::=
    DOT IDENT:memberName
    {:
        if (!curObjWrappFieldOrElem.isSemanticError())
        {
            if (curObjWrappFieldOrElem.isClassType())
            {
                Obj obj = curObjWrappFieldOrElem.getObj().getType().getMembersTable().searchKey(memberName);
                if ( (obj == null)
                ||
                ((obj.getKind() != Obj.Meth)
                || (!isMethodStatic(obj))) )
                {
                    // TODO ispisi
                    RESULT = curObjWrappFieldOrElem.setSemanticError(true);
                }
                else
                {
                    curObjWrappFieldOrElem = new ObjResultWrapper(obj, true);

                    RESULT = curObjWrappFieldOrElem;
                }
            }
            else if (curObjWrappFieldOrElem.isClass())
            {
                Obj obj = curObjWrappFieldOrElem.getObj().getType().getMembersTable().searchKey(memberName);
                if ( (obj == null) || ((obj.getKind() != Obj.Fld) && (obj.getKind() != Obj.Meth) ) )
                {
                    RESULT = curObjWrappFieldOrElem.setSemanticError(true);
                }
                else
                {
                    if (obj.getKind() == Obj.Fld)
                    {
                        // x
                        Code.put(Code.dup);
                        // x x
                        Code.load(obj);
                        // x x.i

                        curObjWrappFieldOrElem = new ObjResultWrapper(obj, false);
                        RESULT = curObjWrappFieldOrElem;
                    }
                    else
                    {
                        curObjWrappFieldOrElem = new ObjResultWrapper(obj, false);
                        curObjWrappFieldOrElem.setVirtual(true);
                        RESULT = curObjWrappFieldOrElem;
                    }
                }
            }
            else
            {
                RESULT = curObjWrappFieldOrElem.setSemanticError(true);
            }
        }
        else
        {
            RESULT = curObjWrappFieldOrElem.setSemanticError(true);
        }
    :}
    |
    BRACKET_LEFT Expr:expr BRACKET_RIGHT
    {:
        if (!curObjWrappFieldOrElem.isSemanticError()
        && !expr.isSemanticError()
        && check_type_and_report(expr.getObj(), Tab.intType,
        exprleft, " indeks niza mora bude tipa int")
        )
            if (curObjWrappFieldOrElem.isArray())
            {
                Struct curArrayDotType = curObjWrappFieldOrElem.getObj().getType().getElemType();
                Obj obj = new Obj(Obj.Elem, "", curArrayDotType);
                curObjWrappFieldOrElem.setObj(obj);
                Code.put(Code.dup2);
                Code.load(obj);
                RESULT = new ObjResultWrapper(obj, false /* RVALUE */);
            }
            else
            {
                semantic_error("Kad se koriste [] sa leve strane mora biti niz", exprleft);
                RESULT = curObjWrappFieldOrElem.setSemanticError(true);
            }
        else
        {
            RESULT = curObjWrappFieldOrElem.setSemanticError(true);
        }

    :}
    |
    BRACKET_LEFT error BRACKET_RIGHT
    {:
        parser.report_error("Uspesan oporavak od greske kod indeksa niza,  BRACKET_RIGHT je resio stvar" , null);
        // TODO test further.
        //
        RESULT = new ObjResultWrapper().setSyntaxError(true);
    :}
    ;


/**********************   AssignOp    ****************************/
/*****************************************************************/
Assignop ::=
            OP_ASSIGN
            {:
                RESULT = OP_ASSIGN_CODE;
            :}
            |
            AddopRight:op
            {:
                RESULT = op;
            :}
            |
            MulopRight:op
            {:
                RESULT = op;
            :};


/**********************   Relop       ****************************/
/*****************************************************************/
Relop ::=
            OP_EQ
            {:
                RESULT = Code.eq;
            :}
            |
            OP_NOT_EQ
            {:
                RESULT = Code.ne;
            :}
            |
            OP_GTE
            {:
                RESULT = Code.ge;
            :}
            |
            OP_GREAT
            {:
                RESULT = Code.gt;
            :}
            |
            OP_LESS
            {:
                RESULT = Code.lt;
            :}
            |
            OP_LTE
            {:
                RESULT = Code.le;
            :}
            ;



/**********************   AddopLeft   ****************************/
/*****************************************************************/
AddopLeft ::=
            OP_ADD
            {:
                RESULT = Code.add;
            :}
            |
            OP_SUB
            {:
                RESULT = Code.sub;
            :}
            ;


/**********************   AddopRight  ****************************/
/*****************************************************************/
AddopRight ::=
            OP_ASSIGN_ADD
            {:
                RESULT = Code.add;
            :}
            |
            OP_ASSIGN_SUB
            {:
                RESULT = Code.sub;
            :}
            ;


/**********************   MulopLeft   ****************************/
/*****************************************************************/
MulopLeft ::=
            OP_MUL
            {:
                RESULT = Code.mul;
            :}
            |
            OP_DIV
            {:
                RESULT = Code.div;
            :}
            |
            OP_MOD
            {:
                RESULT = Code.rem;
            :}
            ;


/**********************   MulopRight  ****************************/
/*****************************************************************/
MulopRight ::=
            OP_ASSIGN_MUL
            {:
                RESULT = Code.mul;
            :}
            |
            OP_ASSIGN_DIV
            {:
                RESULT = Code.div;
            :}
            |
            OP_ASSIGN_MOD
            {:
                RESULT = Code.rem;
            :}
            ;

