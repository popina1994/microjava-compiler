package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

import java.io.*;
import java.util.LinkedList;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.mj.runtime.*;
import rs.etf.pp1.symboltable.visitors.SymbolTableVisitor;

parser code {:

    public static class DumpUpgradeSymbolTableVisitor extends SymbolTableVisitor
    {
        protected StringBuilder output = new StringBuilder();
        protected final String indent = "   ";
        protected StringBuilder currentIndent = new StringBuilder();

        protected void nextIndentationLevel() {
            currentIndent.append(indent);
        }

        protected void previousIndentationLevel() {
            if (currentIndent.length() > 0)
                currentIndent.setLength(currentIndent.length()-indent.length());
        }


        /* (non-Javadoc)
         * @see rs.etf.pp1.symboltable.test.SymbolTableVisitor#visitObjNode(symboltable.Obj)
         */
        @Override
        public void visitObjNode(Obj objToVisit) {
            //output.append("[");
            switch (objToVisit.getKind()) {
            case Obj.Con:  output.append("Con "); break;
            case Obj.Var:  output.append("Var "); break;
            case Obj.Type: output.append("Type "); break;
            case Obj.Meth: output.append("Meth "); break;
            case Obj.Fld:  output.append("Fld "); break;
            case Obj.Prog: output.append("Prog "); break;
            }

            output.append(objToVisit.getName());
            output.append(": ");

            if ((Obj.Var == objToVisit.getKind()) && "this".equalsIgnoreCase(objToVisit.getName()))
                output.append("");
            else
                objToVisit.getType().accept(this);

            output.append(", ");
            output.append("Adr:" + objToVisit.getAdr());
            output.append(", ");
            output.append("Level:" + objToVisit.getLevel() + " ");

            if (objToVisit.getKind() == Obj.Prog || objToVisit.getKind() == Obj.Meth) {
                output.append("\n");
                nextIndentationLevel();
            }


            for (Obj o : objToVisit.getLocalSymbols()) {
                output.append(currentIndent.toString());
                o.accept(this);
                output.append("\n");
            }

            if (objToVisit.getKind() == Obj.Prog || objToVisit.getKind() == Obj.Meth)
                previousIndentationLevel();

            //output.append("]");

        }

        /* (non-Javadoc)
         * @see rs.etf.pp1.symboltable.test.SymbolTableVisitor#visitScopeNode(symboltable.Scope)
         */
        @Override
        public void visitScopeNode(Scope scope) {
            for (Obj o : scope.values()) {
                o.accept(this);
                output.append("\n");
            }
        }

        /* (non-Javadoc)
         * @see rs.etf.pp1.symboltable.test.SymbolTableVisitor#visitStructNode(symboltable.Struct)
         */
        @Override
        public void visitStructNode(Struct structToVisit) {
            switch (structToVisit.getKind()) {
            case Struct.None:
                output.append("notype");
                break;
            case Struct.Int:
                output.append("int");
                break;
            case Struct.Char:
                output.append("char");
                break;
            case Struct.Bool:
                output.append("bool");
                break;
            case Struct.Array:
                output.append("Arr of ");

                switch (structToVisit.getElemType().getKind()) {
                case Struct.None:
                    output.append("notype");
                    break;
                case Struct.Int:
                    output.append("int");
                    break;
                case Struct.Char:
                    output.append("char");
                    break;
                case Struct.Class:
                    output.append("Class");
                    break;
                case Struct.Bool:
                  output.append("bool");
                    break;
                }
                break;
            case Struct.Class:
                output.append("Class [");
                for (Obj obj : structToVisit.getMembers()) {
                    obj.accept(this);
                }
                output.append("]");
                break;
            }

        }

        public String getOutput() {
            StringBuilder tmp = output;
            output = new StringBuilder("");
            return tmp.toString();
        }

    }

    static class TabExt
    {
        static Struct boolType = new Struct(Struct.Bool);
        static SymbolTableVisitor symbolTableVisitor = new DumpUpgradeSymbolTableVisitor();
        static Obj programObj = null;
        static Obj curMethod = null;
        static Obj curClass = null;
        static boolean doesMainExist = false;
    }

    public static class ObjResultWrapper {
        Obj obj;
        boolean isRightValue;
        boolean isLeftValue;
        boolean isVar;
        boolean isField;
        boolean semanticError = false;
        int relOp;

        public ObjResultWrapper(Obj obj, boolean isRightValue) {
            this.obj = obj;
            this.isRightValue = isRightValue;
            this.isLeftValue = !isRightValue;
        }

        public Obj getObj() {
            return obj;
        }
        public void setObj(Obj obj) {
            this.obj = obj;
        }

        public boolean getIsRightValue() {
            return isRightValue;
        }

        public void setRightValue(boolean isRightValue) {
            this.isRightValue = isRightValue;
            this.isLeftValue = !isRightValue;
        }

        public void setLeftValue(boolean isLeftValue) {
            this.isLeftValue = isLeftValue;
            this.isRightValue = !isLeftValue;
        }

        public boolean isLeftValue() {
            return isLeftValue;
        }

        public boolean isSemanticError() {
            return semanticError;
        }

        public ObjResultWrapper setSemanticError(boolean semanticError) {
            this.semanticError = semanticError;
            return this;
        }

        public boolean  isField()
        {
            return isField;
        }

        public boolean isArrayElement()
        {
            return obj.getKind() == Obj.Elem && isLeftValue;
        }

        public boolean isArray()
        {
            return (isLeftValue &&  (obj.getType().getKind() == Struct.Array) );
        }


        public void generateLeftValue()
        {
        }

        public boolean loadable()
        {
            int kind = obj.getKind();
            return (kind == Obj.Con) || (kind == Obj.Var) || (kind == Obj.Fld) || (kind == Obj.Elem);
        }

        public void generateRightValue()
        {
            if (isArrayElement())
            {
                // a i a[i]
                Code.put(Code.dup_x2);
                // a[i] a i a[i]
                Code.put(Code.pop);
                // a[i] a i
                Code.put(Code.pop);
                // a[i] a
                Code.put(Code.pop);
                // a[i]
                setRightValue(true);
            }
        }

        public void setRelOp(int relOp)
        {
            this.relOp = relOp;
        }

        public int getRelOp()
        {
            return relOp;
        }

    }


    // U slucaju greske.
    //
     @Override
    protected int error_sync_size() {
        // TODO Auto-generated method stub
        return 1;
    }

    static class ParserCnt {
        // NIVO A
        static int globalVarDefCnt = 0;
        static int localVarDefMainCnt = 0;
        static int globalConstDefCnt = 0;
        static int globalArrayDeclCnt = 0;

        // NIVO B
        static int globalAndStaticMethodCnt = 0;
        //static int l

        static boolean inVarDeclGlobalScope = false;
        static boolean inMethodDeclGlobalScope = false;
        static boolean inMethodEntryGlobalScope = false;
    }

    boolean errorDetected = false;
    boolean syntaxError = false;
    boolean semanticError = false;
    String fileName = "test/generator/program.obj";


    public void setFileName(String fileName){
        this.fileName = fileName;
    }

    Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    // MJParser greska.
    //
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    // Overrideovana MJParser funkcija.
    //
    public void syntax_error(Symbol cur_token) {
        syntaxError = true;
        report_error("\nSintaksna greska", cur_token);
    }

    public void semnatic_error(String msg, Symbol sym)
    {
        semanticError = true;
        report_error("\nSemnaticka greska : " + msg, sym);
    }


    // Overrideovana MJParser funkcija.
    //
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    // Sa vezbi funkcija.
    //
    public void report_error(String message, Object info) {
        errorDetected = true;
        StringBuilder msg = new StringBuilder(message);
        if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
        StringBuilder msg = new StringBuilder(message);
        if (info instanceof Symbol)
        {
            Symbol symbol = (Symbol)info;
            msg.append(symbol.toString()).append (" na liniji ").append(symbol.left);
        }
        log.info(msg.toString());
    }


    static class WrapperObj
    {
        private Obj obj;
        private boolean isFoundAndTypeMatch;

        WrapperObj(Obj obj, boolean isFoundAndTypeMatch) {
            this.obj = obj;
            this.isFoundAndTypeMatch = isFoundAndTypeMatch;
        }

        Obj getObj() { return obj; }
        boolean isFoundAndTypeMatch() { return isFoundAndTypeMatch; }

        boolean isFound() { return obj != Tab.noObj; }
        boolean isTypeMismatch(){
            return isFound() && !isFoundAndTypeMatch;
        }


    }



    public WrapperObj find_and_report_search(String name, int line, Struct type, String additionalMessage)
    {
        Obj obj = Tab.find(name);
        WrapperObj retWrapperObj = null;

        if (Tab.noObj == obj)
        {
            retWrapperObj = new WrapperObj(obj, false);
        }
        else if (!type.equals(obj.getType()))
        {
            retWrapperObj = new WrapperObj(obj, false);
        }
        else
        {
            retWrapperObj = new WrapperObj(obj, true);
        }

        if (null != additionalMessage)
        {
            additionalMessage += " simbol " + name + " na liniji " + line;
            if (retWrapperObj.isFoundAndTypeMatch)
            {
                additionalMessage += " nadjen simbol";
                report_info(additionalMessage, null);

            }
            else if (retWrapperObj.isTypeMismatch()) {
                additionalMessage += " nije ispravnog tipa";
                semnatic_error(additionalMessage, null);
            }
            else
            {
                additionalMessage += " nije nadjen ";
                semnatic_error(additionalMessage, null);
            }

        }
        return retWrapperObj;
    }

    boolean find_double_and_report_search(String name, int line, String additionalMessage)
    {
        Scope currentScope = Tab.currentScope;

        Obj objDoubleDef = currentScope.findSymbol(name);
        // Nadjen je duplikat u okruzujucem opsegu.
        //
        if (objDoubleDef != null)
        {
            additionalMessage += " simbol " + name + " na liniji " + line + " Vec postoji";
            semnatic_error(additionalMessage, null);
            return true;
        }
        else
        {
            return false;
        }
    }

    boolean check_type_and_report(Obj obj, Struct type, int line, String additionalMessage)
    {
        if (!obj.getType().equals(type) && ( additionalMessage != null) ){
            semnatic_error(additionalMessage + " Tipovi nisu kompatibilni linija" + line, null);
            return false;
        }
        return true;
    }

    WrapperObj find_for_use(String name, String additionalMessage)
    {
        return null;
    }



:}

action code {:
    final String METHOD_ENTRY_NAME = "main";
    final int OP_ASSIGN_CODE = 0;
    final int CHAR_SIZE = 1;
    final int INT_SIZE = 4;
    Struct curConstType = null;
    Struct curVarType = null ;
    Struct curLocalType = null;
    Struct curFormType = null;
    Obj curObjFieldOrElem = null;
    ObjResultWrapper curObjWrappFieldOrElem = null;
    LinkedList<ObjResultWrapper> listCurObjWrapperFieldOrElem = new LinkedList<ObjResultWrapper>();
    LinkedList<Integer> listAdrConditionTrue = new LinkedList<Integer>();
    LinkedList<Integer> listAdrConditionFalse = new LinkedList<Integer>();

    boolean globalVar = false;
    boolean localVar = false;
    boolean formVar = false;
    int formParCnt = 0;

:}

scan with {:
    Symbol s = this.getScanner().next_token();
    if (s != null && s.value != null)
        log.debug(s.toString() + " " + s.value.toString());
    return s;
:}


init with {:
    Tab.init(); // Universe scope
:}


terminal PROGRAM, STATIC, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, FOR, EXTENDS, CONTINUE;
terminal String IDENT;
terminal Integer CONST_NUM;
terminal String CONST_CHAR;
terminal String CONST_BOOL;
terminal OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_MOD, OP_EQ, OP_NOT_EQ, OP_GREAT, OP_LESS, OP_GTE, OP_LTE;
terminal OP_AND, OP_OR, OP_ASSIGN, OP_ASSIGN_ADD, OP_ASSIGN_SUB, OP_ASSIGN_MUL, OP_ASSIGN_DIV, OP_ASSIGN_MOD;
terminal OP_INC, OP_DEC, SEMI_COLUMN, COMMA, DOT, PAR_LEFT, PAR_RIGHT;
terminal BRACKET_LEFT, BRACKET_RIGHT, BRACE_LEFT, BRACE_RIGHT;

non terminal Program;
non terminal GlobalDeclListEpsilon, GlobalDeclList, GlobalDecl, GlobalVarDecl, MethodDeclListEpsilon, MethodDeclList;

non terminal ConstDecl, ConstExprList, ConstExpr;
non terminal Obj ConstNum;
non terminal Obj ConstChar;
non terminal Obj ConstBool;
non terminal Obj ConstValue;
non  terminal Struct VarExpr;
non terminal GlobalVarExprList, GlobalVarExprCommaList, VarExprOrErrorSemi, VarExprOrErrorComma;
non terminal Boolean BracketEpsilon;
non terminal ClassDecl, ExtendsTypeEpsilon, FieldDeclListEpsilon, FieldDeclList, FieldDecl, FieldExprList, BraceMethodDeclListEpsilonEpsilon;

non terminal MethodDecl, StaticEpsilon;
non terminal  Struct ReturnType;
non terminal  LocalVarDeclListBraceLeftEpsilon, LocalVarDeclListBraceLeft, LocalVarDeclOrErrorSemi, LocalVarDeclListOrErrorSemi, LocalVarExprList, LocalVarDeclOrErrorBraceLeft, StatementListEpsilon, StatementList;
non terminal FormPars, FormPar, FormParsEpsilonParRight, FormParOrErrorComma, FormParsParRight, FormParOrErrorParRight;
non terminal Struct Type;
non terminal Statement, ElseStatementEpsilon, ExprEpsilon, IfConditionParRight;
non terminal Obj CommaConstNumEpsilon;
non terminal DesignatorStatement, ActParsEpsilon, ActPars, CommaExprListEpsilon, CommaExprList, CommaExpr, DesignatorStatementOrAssignErrorSemi, DesignatorStatementOrAssignOrErrorSemi, ForConditionSemi, DesignatorStatementOrAssignOrErrorParRight, AssingmentStatement, DesignatorStatementOrAssign, AssingmentStatementOrErrorSemi;
non terminal ObjResultWrapper DesignatorIncOrDec;
non terminal ObjResultWrapper DesignatorFuncCall;
non terminal Integer IncOrDec;
non terminal ObjResultWrapper ExpOrErrorSemi;
non terminal ObjResultWrapper AssignOpExpOrErrorSemi;
non terminal ForCondition;
non terminal ObjResultWrapper OpOrCondTermList;
non terminal ObjResultWrapper CondTerm;
non terminal ObjResultWrapper OpAndCondFactList;
non terminal ObjResultWrapper CondFact;
non terminal ObjResultWrapper RelOpExprOrEpsilon;
non terminal ObjResultWrapper Expr;
non terminal Boolean OpSubEpsilon;
non terminal ObjResultWrapper AddopRightTerm;
non terminal ObjResultWrapper AddopLeftTerm;
non terminal ObjResultWrapper Term;
non terminal ObjResultWrapper MullopRightFactor;
non terminal ObjResultWrapper  MulopLeftFactor;
non terminal ObjResultWrapper Factor;
non terminal ParActParsEpsilonEpsilon;
non terminal Boolean BracketExprEpsilon;
non terminal ObjResultWrapper Designator;
non terminal ObjResultWrapper DotIdentOrBracketExprListEpsilon;
non terminal ObjResultWrapper DotIdentOrBracketExprList;
non terminal ObjResultWrapper DotIdentOrBracketExpr;
non terminal Integer Assignop;
non terminal Integer Relop;
non terminal Integer AddopLeft;
non terminal Integer AddopRight;
non terminal Integer MulopLeft;
non terminal Integer MulopRight;


precedence left ELSE;

/************************* PROGRAM **************************/
/************************************************************/
Program ::=
    {:
        parser.report_info("Krece da prepoznaje globalne deklaracije", null);
    :}
    PROGRAM
    IDENT : programName
    {:

        Tab.insert(Obj.Type, "bool", TabExt.boolType);
        TabExt.programObj = Tab.insert(Obj.Prog, programName, Tab.noType);

        Tab.openScope();
    :}
    GlobalDeclListEpsilon
    BRACE_LEFT
    MethodDeclListEpsilon
    BRACE_RIGHT
    {:
        Code.dataSize = Tab.currentScope().getnVars();
        Tab.chainLocalSymbols(TabExt.programObj);
        Tab.closeScope();


        parser.report_info("************** NIVO A*****************", null);
        parser.report_info("Broj definicija globalnih promenljivih " + ParserCnt.globalVarDefCnt, null);
        parser.report_info("Broj definicija lokalnih promenljivih u main funkciji " + ParserCnt.localVarDefMainCnt, null);
        parser.report_info("Broj definicija globalnih konstanti " + ParserCnt.globalConstDefCnt, null);
        parser.report_info("Broj deklaracija globalnih nizova " + ParserCnt.globalArrayDeclCnt, null);
        parser.report_info("************** NIVO B*****************", null);
        parser.report_info("Broj definicija globalnih i statickih funkcija unutrasnjih klasa " + ParserCnt.globalAndStaticMethodCnt, null);
        parser.report_info("USPESNO PREPOZNAVANJE", null);
        Tab.dump(TabExt.symbolTableVisitor);

        if (errorDetected)  {
            parser.report_error("Neuspesno parsiranje!!!", null);
        }
        else if (!TabExt.doesMainExist)
        {
            parser.report_error("Ne postoji globalna main funkcija!!!", null);
        }
        else {
            parser.log.info("Uspesno parsiranje!!!", null);
            //String fileName = "test/generator/program.obj";
            File f = new File(fileName);
            if (f.exists())
            {
                f.delete();
            }
            f = new File(fileName);
            Code.write(new FileOutputStream(f));

        }
    :}
    ;

GlobalDeclListEpsilon ::=
    GlobalDeclList
	|
	/* epsilon */
	;

GlobalDeclList ::=
    GlobalDeclList GlobalDecl
    |
    GlobalDecl
    ;

GlobalDecl ::=
    ConstDecl
    {:
        //Tab.dump(TabExt.symbolTableVisitor);
    :}
	|
    // Samo zbog oporavka od greske.
    //
	GlobalVarDecl
    {:
        //Tab.dump(TabExt.symbolTableVisitor);
    :}
	|

	ClassDecl
    {:
        parser.log.debug("Prepoznata klasa", null);
    :}
    ;


GlobalVarDecl ::=
    Type:varType
    {:
        curVarType = varType;
        globalVar = true;
    :}
    GlobalVarExprList
    {:
        globalVar = false;
    :}
    ;
GlobalVarExprList ::=
    GlobalVarExprCommaList VarExprOrErrorSemi
    |
    VarExprOrErrorSemi
    ;

VarExprOrErrorSemi ::=
    VarExpr:t
    SEMI_COLUMN
    |
    error:text SEMI_COLUMN
    {:
        parser.report_error("Uspesan oporavak od greske deklaracije globalne promenljive,  SEMI_COLUMN je resio stvar" , null);
    :}
    ;

GlobalVarExprCommaList ::=
    GlobalVarExprCommaList VarExprOrErrorComma
    |
    VarExprOrErrorComma
    ;
VarExprOrErrorComma ::=
    VarExpr:t
    COMMA
    |
    error COMMA
    {:
        parser.report_error("Uspesan oporavak od greske prilikom deklaracije globalne promenljiva COMMA je resila stvar", null);
    :}
    ;



MethodDeclListEpsilon ::=
    MethodDeclList
	|
	/* epsilon */
	;

MethodDeclList ::=
    MethodDeclList MethodDecl
    |
    MethodDecl
    ;

/************************* ConstDecl ************************/
/************************************************************/
ConstDecl ::=
    CONST Type:type
    {:
        curConstType = type;
    :}
    ConstExprList
    {:

    :}SEMI_COLUMN
    ;

ConstExprList ::=
    ConstExprList COMMA ConstExpr
    |
    ConstExpr
    ;

ConstExpr ::=
    IDENT:nameOfConst OP_ASSIGN ConstValue:numObj
    {:
        // Da li se konstanta slaze po tipu sa deklaracijom.
        //
        if (check_type_and_report(numObj, curConstType, numObj.getLevel(), " poredjenje tipova konstanti"))
        {
            // Da nema slucajno duplikata.
            //
            if (!find_double_and_report_search(nameOfConst, nameOfConstleft, "Konstanta"))
            {
                 Obj constObj = Tab.insert(Obj.Con, nameOfConst, curConstType);
            constObj.setAdr(numObj.getAdr());
            }

        }

    :}
    ;



ConstValue ::=
        ConstNum:constNum
        {:
            RESULT = constNum;
        :}
        |
        ConstBool:constBool
        {:
            RESULT = constBool;
        :}
        |
        ConstChar:constChar
        {:
            RESULT = constChar;
        :}
        ;

ConstNum ::=
        CONST_NUM:number
        {:
            RESULT = new Obj(Obj.Con, number.toString(), Tab.intType, number.intValue(), numberleft);
        :}
        ;

ConstBool ::=
        CONST_BOOL:boolStr
        {:
            RESULT = new Obj(Obj.Con, "", TabExt.boolType, Boolean.valueOf(boolStr) ? 1 : 0, boolStrleft);
        :}
        ;

ConstChar ::=
        CONST_CHAR : charStr
        {:
            char c = charStr.charAt(1);
            RESULT = new Obj(Obj.Con, "", Tab.charType,
            c, charStrleft);

        :}
        ;

/************************* VarDecl **************************/
/************************************************************/



VarExpr ::=
    IDENT:nameOfVar
    BracketEpsilon:isArray
    {:
        Struct type = null;
        String message = "";
        Obj varObj = null;


        if (globalVar)
        {
            message = "Definicija globalne varijable";
            type = curVarType;
        }
        else if (localVar)
        {
            message = "Definicija lokalne varijable";
            type = curLocalType;
        }
        else if (formVar)
        {
            message = "Definicija formalnog parametra";
            type = curFormType;
        }

        if (isArray)
        {
            type = new Struct (Struct.Array, type);
        }

        if (!find_double_and_report_search(nameOfVar, nameOfVarleft, message))
        {
            varObj = Tab.insert(Obj.Var, nameOfVar, type);
            if (formVar)
            {
                varObj.setAdr(Tab.currentScope().getnVars() - 1);
            }
        }


    :}
    ;

BracketEpsilon ::=
    BRACKET_LEFT
    BRACKET_RIGHT
    {:
        RESULT = true;
    :}
    |
    {:
        RESULT = false;
    :}
    ;


/************************* ClassDecl **************************/
/************************************************************/
ClassDecl ::=
        CLASS
        IDENT:nameOfClass

		ExtendsTypeEpsilon
		BRACE_LEFT
		FieldDeclListEpsilon
        BraceMethodDeclListEpsilonEpsilon
		BRACE_RIGHT
        {:
            parser.log.debug("Prepoznata CLASS", null);
        :}
        ;

ExtendsTypeEpsilon ::=
            EXTENDS Type
            |
            /* epsilon */
            ;

FieldDeclListEpsilon ::=
            FieldDeclList
            |
            /* epsilon */
            ;
FieldDeclList ::=
            FieldDeclList FieldDecl
            |
            FieldDecl
            ;


FieldDecl ::= Type FieldExprList SEMI_COLUMN;
FieldExprList ::=
            FieldExprList COMMA VarExpr
            |
            VarExpr
            ;

BraceMethodDeclListEpsilonEpsilon ::=
            BRACE_LEFT MethodDeclListEpsilon BRACE_RIGHT
            |
            /* epsilon */
            ;

/************************* MethodDecl **************************/
/************************************************************/
MethodDecl ::=
        StaticEpsilon:isStatic

        ReturnType:retType
        {:
            parser.log.debug("Prepoznat povratni tip", null);
        :}
        IDENT:nameOfMethod
        {:
            String message = "Metoda";
            if (!find_double_and_report_search(nameOfMethod, nameOfMethodleft, message))
            {
                TabExt.curMethod  = Tab.insert(Obj.Meth, nameOfMethod, retType);
            }

        :}
        PAR_LEFT
        {:
            Tab.openScope();
        :}
        FormParsEpsilonParRight
        {:
            if (null != TabExt.curMethod)
            {
                // Postavi broj formalnih parametara.
                //
                TabExt.curMethod.setLevel(Tab.currentScope().getnVars());
            }
        :}
        LocalVarDeclListBraceLeftEpsilon
        {:
            if (null != TabExt.curMethod)
            {
                Tab.chainLocalSymbols(TabExt.curMethod);
            }
            // TODO : Sumnjivo mi ovo nesto, mozda ranije treba (da bi se spremio stek)
            //
            TabExt.curMethod.setAdr(Code.pc);
            if (nameOfMethod.equals(METHOD_ENTRY_NAME))
            {
                TabExt.doesMainExist = true;
                Code.mainPc = TabExt.curMethod.getAdr();

            }

            Code.put(Code.enter);
            Code.put(TabExt.curMethod.getLevel());
            Code.put(Tab.currentScope().getnVars());

            parser.log.debug("Zavrseno prepoznavanje deklaracija lokalnih promen", null);
        :}
        StatementListEpsilon
        BRACE_RIGHT
        {:
            // Dealocira se stek.
            //
            if (retType == Tab.noType)
            {
                Code.put(Code.exit);
                Code.put(Code.return_);
            }
            else
            {
                // Error in case of no return.
                //
                Code.put(Code.trap);
                Code.put(1);
            }

            Tab.closeScope();
            parser.log.debug("Prepoznat METHOD", null);
        :}
        ;
StaticEpsilon ::=
            STATIC
            {:
                RESULT = new Boolean(true);
            :}

            |
            /*epsilon*/
            {:
                RESULT = new Boolean(false);
            :}
            ;
ReturnType ::=
            Type:type
            {:
                RESULT = type;
            :}
            |
            VOID
            {:
                RESULT = Tab.noType;
            :}
            ;
FormParsEpsilonParRight ::=
            FormParsParRight
            |
            PAR_RIGHT
            ;
LocalVarDeclListBraceLeftEpsilon ::=
            LocalVarDeclListBraceLeft
            |
            BRACE_LEFT
            ;

LocalVarDeclListBraceLeft ::=
            LocalVarDeclListOrErrorSemi LocalVarDeclOrErrorBraceLeft
            |
            LocalVarDeclOrErrorBraceLeft
            ;

LocalVarDeclListOrErrorSemi ::=
            LocalVarDeclListOrErrorSemi LocalVarDeclOrErrorSemi
            |
            LocalVarDeclOrErrorSemi
            ;

LocalVarDeclOrErrorSemi ::=
            Type:type
            {:
                curLocalType =  type;
                localVar = true;
            :}
            LocalVarExprList SEMI_COLUMN
            {:
                localVar = false;
            :}
            |
            error:text SEMI_COLUMN
            {:
              parser.report_error("Uspesan oporavak od greske deklaracije lokalne promenljive,  SEMI_COLUMN je resio stvar" , null);
            :}
            ;
LocalVarExprList ::=
            LocalVarExprList COMMA VarExpr
            |
            VarExpr
            ;

LocalVarDeclOrErrorBraceLeft ::=
            error:text BRACE_LEFT
            {:
                  parser.report_error("Uspesan oporavak od greske deklaracije lokalne promenljive,  BRACE_LEFT je resila stvar" , null);
            :}
            |
            LocalVarDeclOrErrorSemi BRACE_LEFT
            ;

StatementListEpsilon ::=
            StatementList
            |
            /* epsilon */
            ;
StatementList ::=
            StatementList Statement
            |
            Statement
            ;

/************************* FormPars **************************/
/************************************************************/
FormParsParRight ::=
            FormPars FormParOrErrorParRight
            |
            FormParOrErrorParRight
            ;

FormPars ::=
            FormPars FormParOrErrorComma
            |
            FormParOrErrorComma
            ;

FormParOrErrorComma ::=
            FormPar COMMA
            |
            error COMMA
            {:
                  parser.report_error("Uspesan oporavak od greske deklaracije formalnog parametra lokalne funkcije,  COMMA je resila stvar" , null);
            :}
            ;

FormParOrErrorParRight ::=
            FormPar PAR_RIGHT
            |
            error PAR_RIGHT
            {:
                  parser.report_error("Uspesan oporavak od greske deklaracije formalnog parametra lokalne funkcije,  PAR_RIGHT je resio stvar" , null);
            :}
            ;

FormPar::=
            Type:type
            {:
                curFormType = type;
                formVar = true;
            :}
            VarExpr
            {:
                formVar = false;
            :}
            ;




/************************* Type **************************/
/************************************************************/
Type ::=
        IDENT:nameOfType
        {:

            Obj obj = Tab.find(nameOfType);
            if (obj.getKind() != Obj.Type)
            {
                RESULT = Tab.noType;
                semnatic_error("Nije definisan tip" + nameOfType + "na liniji" + nameOfTypeleft, null);
            }
            else
            {
                RESULT = obj.getType();
            }
        :}
        ;


/************************* Statement **************************/
/************************************************************/

Statement ::=
        DesignatorStatementOrAssignErrorSemi
        {:
            parser.log.debug("Prepoznata STATEMENT", null);
        :}
        |
        // TODO : add check for type of expression.
        //
        IF PAR_LEFT IfConditionParRight
        {:
            // FALSE.
            //
            Code.put(Code.const_n);
            Code.putFalseJump(Code.ne, 0);
            int adrConditionFalse = Code.pc - 2;
            listAdrConditionFalse.addLast(adrConditionFalse);
        :}
        Statement
        {:

            Code.putJump(0);
            Code.fixup(listAdrConditionFalse.removeLast());
            int adrConditionTrue = Code.pc - 2;
            listAdrConditionTrue.addLast(adrConditionTrue);
        :}
        ElseStatementEpsilon
        {:

            Code.fixup(listAdrConditionTrue.removeLast());
            parser.log.debug("Prepoznat IF", null);
        :}
        |
        FOR PAR_LEFT DesignatorStatementOrAssign SEMI_COLUMN   ForConditionSemi  DesignatorStatementOrAssignOrErrorParRight
            Statement
        |
        FOR error SEMI_COLUMN ForCondition SEMI_COLUMN DesignatorStatementOrAssign PAR_RIGHT
        |
        FOR DesignatorStatementOrAssign SEMI_COLUMN error SEMI_COLUMN DesignatorStatementOrAssign PAR_RIGHT
        |
        FOR DesignatorStatementOrAssign SEMI_COLUMN ForCondition SEMI_COLUMN error PAR_RIGHT
        |
        FOR error SEMI_COLUMN error SEMI_COLUMN DesignatorStatementOrAssign PAR_RIGHT
        |
        FOR error SEMI_COLUMN ForCondition SEMI_COLUMN error PAR_RIGHT
        |
        FOR DesignatorStatementOrAssign SEMI_COLUMN error SEMI_COLUMN error PAR_RIGHT
        |
        FOR error SEMI_COLUMN error SEMI_COLUMN error PAR_RIGHT
        |
        FOR error SEMI_COLUMN error PAR_RIGHT
        |
        FOR error PAR_RIGHT
        |
        BREAK SEMI_COLUMN
        {:
            parser.log.debug("Prepoznat BREAK", null);
        :}
        |
        CONTINUE SEMI_COLUMN
        {:
            parser.log.debug("Prepoznat CONTINUE", null);
        :}
        |
        RETURN ExprEpsilon SEMI_COLUMN
        {:
            // TODO : return check semantic.
            // Should exist, are types ok...
            //
            Code.put(Code.exit);
            Code.put(Code.return_);

            parser.log.debug("Prepoznat RETURN", null);
        :}
        |
        READ PAR_LEFT Designator:des PAR_RIGHT SEMI_COLUMN
        {:
            if (des.isLeftValue() &&
                (des.getObj().getType().equals(Tab.intType)
                || (des.getObj().getType().equals(Tab.charType))
                || (des.getObj().getType().equals(TabExt.boolType))))
            {
                Code.put(Code.pop);
                if (des.getObj().getType().equals(Tab.charType))
                {
                    Code.put(Code.bread);
                }
                else
                {
                    Code.put(Code.read);
                }
                Code.store(des.getObj());
            }
            else
            {

            }
            parser.log.debug("Prepoznat READ", null);
        :}
        |
        PRINT PAR_LEFT Expr:expr CommaConstNumEpsilon:numObj PAR_RIGHT SEMI_COLUMN
        {:
            Struct typeExpr = expr.getObj().getType();
            if (typeExpr.equals(TabExt.boolType)
                || typeExpr.equals(Tab.intType)
                || typeExpr.equals(Tab.charType))
                {
                    // Da li ima dodatnog parametra.
                    //
                    if (!numObj.getType().equals(Tab.noType))
                    {
                        Code.load(numObj);
                    }
                    else
                    {
                        Code.loadConst(0);
                    }
                    if (typeExpr.equals(Tab.charType))
                    {
                        Code.put(Code.bprint);
                    }
                    else
                    {
                        Code.put(Code.print);
                    }

                    if (expr.isArrayElement())
                    {
                        Code.put(Code.pop);
                        Code.put(Code.pop);
                    }
                }
                else
                {
                    expr.setSemanticError(true);
                }
            RESULT = expr;
            parser.log.debug("Prepoznat PRINT");
        :}
        |
        BRACE_LEFT StatementListEpsilon BRACE_RIGHT
        {:
            parser.log.debug("Prepoznat BLOK", null);
        :}
        ;

ElseStatementEpsilon ::=
        ELSE
        Statement

        {:
            parser.log.debug("Prepoznat ELSE", null);
        :}
        |
        /* epsilon */
        ;

ExprEpsilon ::=
        Expr
        |
        /* epsilon */
        ;



ForConditionSemi ::=
        ForCondition SEMI_COLUMN
        |
        SEMI_COLUMN
        |
        error SEMI_COLUMN
        {:
              parser.report_error("Uspesan oporavak od greske kod uslova u for-u,  SEMI_COLUMN je resio stvar" , null);
        :}
        ;

CommaConstNumEpsilon ::=
        COMMA CONST_NUM:number
        {:
            RESULT = new Obj(Obj.Con, number.toString(), Tab.intType, number.intValue(), numberleft);
        :}
        |
        {:
            RESULT = new Obj(Obj.Con, "", Tab.noType);
        :}
        ;

/* ovde moze biti igranja */
/******************* Designator Statement *******************/
/************************************************************/


DesignatorStatementOrAssign ::=

            DesignatorStatement
            |
            AssingmentStatement
            |
            /* epsilon */
            ;

DesignatorStatementOrAssignOrErrorParRight ::=
            DesignatorStatement PAR_RIGHT
            |
            AssingmentStatement PAR_RIGHT
            |
            PAR_RIGHT
            |
            error PAR_RIGHT
            {:
                  parser.report_error("Uspesan oporavak od greske kod inkrementatorra u for-u,  PAR_RIGHT je resio stvar" , null);
            :}
            ;

DesignatorStatementOrAssignErrorSemi ::=
        DesignatorStatement SEMI_COLUMN
        |
        AssingmentStatementOrErrorSemi:expr
        {:
            RESULT = expr;
        :}
        ;


DesignatorStatement ::=
        DesignatorIncOrDec:incOrDec
        {:
            RESULT = incOrDec;
        :}
        |
        DesignatorFuncCall:funcCall
        {:
            if (funcCall.getObj().getType() != Tab.noType)
            {
                Code.put(Code.pop);
            }
            RESULT = funcCall;
        :}
        ;

DesignatorIncOrDec ::=
        Designator:designator IncOrDec:op
        {:
            if (!designator.isSemanticError() &&
                designator.isLeftValue() && designator.getObj().getType().equals(Tab.intType))
                {
                    Code.loadConst(1);
                    Code.put(op);
                    Code.store(designator.getObj());
                    designator.setRightValue(true);
                }
                else
                {
                    RESULT = designator.setSemanticError(true);
                }
        :}
        ;

IncOrDec ::=
    OP_INC
    {:
        RESULT = Code.add;
    :}
    |
    OP_DEC
    {:
        RESULT = Code.sub;
    :}
    ;

DesignatorFuncCall ::=
        Designator:func
        PAR_LEFT ActParsEpsilon PAR_RIGHT
        {:
            Code.put(Code.call);
            // Because Code.call is put then pc  = pc + 1.
            //
            int adr = func.getObj().getAdr() - Code.pc + 1;
            Code.put2(adr);
            RESULT = func;
        :}
        ;

ActParsEpsilon ::=
        ActPars
        |
        /* epsilon */
        ;

AssingmentStatement ::=
        Designator:dst
        Assignop:op
        Expr : expr
        ;

AssingmentStatementOrErrorSemi ::=
        Designator:dest
        Assignop:op
        {:
            if (dest.isSemanticError() || !dest.isLeftValue())
            {
                RESULT = dest.setSemanticError(true);
            }
            else
            {
                if (dest.isArrayElement() && op == OP_ASSIGN_CODE)
                {
                    // a i a[i]
                    Code.put(Code.pop);
                    // a i
                }
            }

        :}
        AssignOpExpOrErrorSemi : expr
        {:
            // Check error.
            //
            if (!dest.isSemanticError() && dest.isLeftValue() &&
                !expr.isSemanticError())
            {
                if (expr.isArrayElement())
                {
                        // a i a[i]
                    Code.put(Code.dup_x2);
                    // a[i] a i a[i]
                    Code.put(Code.pop);
                    // a[i] a i
                    Code.put(Code.pop);
                    // a[i] a
                    Code.put(Code.pop);
                    // a[i]
                }

                if (op != OP_ASSIGN_CODE)
                {
                    // Vrednost na steku nije duplirana jer
                    // treba samo da se koristi za izracunavanje
                    // Nista za dalje vrednosti.
                    Code.put(op);
                }
                else
                {
                    if (dest.isArrayElement())
                    {
                        /*
                        // a i a[i] nesto
                        Code.put(Code.dup_x1);
                        // a i nesto a[i] nesto
                        Code.put(Code.pop);
                        // a i nesto a[i]
                        Code.put(Code.pop);
                        // a i nesto
                        */
                    }
                }
                Code.store(dest.getObj());
                if ( (op == OP_ASSIGN_CODE)
                    && !dest.isArrayElement())
                {
                    Code.put(Code.pop);
                }
            }
            else
            {
                RESULT = dest.setSemanticError(true);
            }
        :}
        ;

AssignOpExpOrErrorSemi ::=
        ExpOrErrorSemi:expr
        {:
            RESULT = expr;
        :}
        ;

ExpOrErrorSemi ::=
        Expr:expr SEMI_COLUMN
        {:
            RESULT = expr;
        :}
        |
        error SEMI_COLUMN
        {:

        parser.report_error("Uspesan oporavak od greske dodele promenljive,  SEMI_COLUMN je resio stvar", null);
        :}
        ;

/******************* ActPars  *******************************/
/************************************************************/
ActPars ::=
        Expr
        CommaExprListEpsilon
        ;

CommaExprListEpsilon ::=
        CommaExprList
        |
        /* epsilon */
        ;
CommaExprList ::=
        CommaExprList CommaExpr
        |
        CommaExpr
        ;
CommaExpr ::=
        COMMA Expr
        ;

/******************* Condition  *****************************/
/************************************************************/
ForCondition ::=
            OpOrCondTermList
            ;
IfConditionParRight ::=
            OpOrCondTermList:cond PAR_RIGHT
            {:
                RESULT = cond;
            :}
            |
            error PAR_RIGHT
            {:
                parser.report_error("Uspesan oporavak od greske prilikom definisanja uslova za if PAR_RIGHT je resila stvar", null);
            :}
            ;
OpOrCondTermList ::=
        OpOrCondTermList OP_OR CondTerm
        // TODO : add checks
        //
        {:
            Code.put(Code.add);
        :}
        |
        CondTerm
        ;

/******************* CondTerm   *****************************/
/************************************************************/
CondTerm ::=
        OpAndCondFactList
        ;
OpAndCondFactList ::=
        OpAndCondFactList:leftFact OP_AND CondFact:rightFact
        // TODO add check if is boolType
        //
        {:
            Code.put(Code.mul);
        :}
        |
        CondFact
        ;

/******************* CondFact   *****************************/
/************************************************************/
CondFact ::=
        Expr:expr
        {:
            expr.generateRightValue();
        :}
        RelOpExprOrEpsilon:compareRight
        {:
            //

            if (null == compareRight)
            {
                // TODO : add checki if is boolean
                //
                //RESULT = expr;
            }
            else
            {
                // JCONDFALSE.
                //
                Code.putFalseJump(compareRight.getRelOp(), 0);
                int adrFromWhereToJumpFalse = Code.pc - 2;
                // TRUE.
                //
                Code.put(Code.const_1);
                Code.putJump(0);
                int adrFromWhereToJumpTrue = Code.pc - 2;

                Code.fixup(adrFromWhereToJumpFalse);
                // False.
                //
                Code.put(Code.const_n);
                // JMP over this
                Code.fixup(adrFromWhereToJumpTrue);
            }

            RESULT = new ObjResultWrapper(new Obj(Obj.Con, "", TabExt.boolType), true);
        :}
        ;
RelOpExprOrEpsilon ::=
        Relop:relOp
        Expr:expr
        {:
            expr.generateRightValue();
            expr.setRelOp(relOp);
            RESULT = expr;
        :}
        |
        /* epsilon */
        {:
            RESULT = null;
        :}
        ;


/******************* Expr       *****************************/
/************************************************************/
Expr ::=
        OpSubEpsilon:isNegative
        AddopRightTerm:term
        {:
            if (isNegative && term.getObj().getType().equals(Tab.intType))
            {
                Code.put(Code.neg);
                term.generateRightValue();
                RESULT = term;
            }
            else if (!isNegative)
            {
                RESULT = term;
            }
            else
            {
                RESULT = term.setSemanticError(true);
            }

        :}
        ;

OpSubEpsilon ::=
        OP_SUB
        {:
            RESULT = true;
        :}
        |
        {:
            RESULT = false;
        :}
        ;

AddopRightTerm ::=
        AddopLeftTerm:leftTerm AddopRight:op

        AddopRightTerm:rightTerm
        {:
        // Treba dodati provere za polja i sve ostale gluposti
        //
        if (leftTerm.getObj().getType().equals(Tab.intType) &&
        rightTerm.getObj().getType().equals(Tab.intType)
        && leftTerm.isLeftValue()
        && !leftTerm.isSemanticError()
        && !rightTerm.isSemanticError())
        {
            rightTerm.generateRightValue();
            Code.put(op);
            if (leftTerm.isArrayElement())
            {
                // a i sum
                Code.put(Code.dup_x2);
                // sum a i sum
            }
            else
            {
                Code.put(Code.dup);
            }
            // sum
            Code.store(leftTerm.getObj());
            // TO DO : ARray class and other shit.
            //

            leftTerm.setRightValue(true);
            RESULT = leftTerm;
        }
        else
        {
            // set errorr;
            RESULT = leftTerm.setSemanticError(true);
        }
    :}
        |
        AddopLeftTerm:type
        {:
            RESULT = type;
        :}
        ;
AddopLeftTerm ::=
        AddopLeftTerm:leftTerm AddopLeft:op Term:rightTerm
        {:
        if (leftTerm.getObj().getType().equals(Tab.intType)
        && (rightTerm.getObj().getType().equals(Tab.intType)))
        {
            rightTerm.generateRightValue();
            Code.put(op);
            leftTerm.generateRightValue();
            RESULT = new ObjResultWrapper(new Obj(Obj.Con,"",Tab.intType), true);
        }
        else
        {
            RESULT = leftTerm.setSemanticError(true);
        }
        :}
        |
        Term:term
        {:
            RESULT = term;
        :}
        ;

/**********************   Term       *****************************/
/*****************************************************************/
Term ::=
            MullopRightFactor:rightFactor
            {:
                RESULT = rightFactor;
            :}
            ;

MullopRightFactor ::=
        MulopLeftFactor:leftFactor
        MulopRight:op
        // a i expr -> expr a i expr
        MullopRightFactor:rightFactor
        {:
            // Treba dodati provere za polja i sve ostale gluposti
            //
            if (leftFactor.getObj().getType().equals(Tab.intType) &&
            rightFactor.getObj().getType().equals(Tab.intType)
            && leftFactor.isLeftValue()
            && !leftFactor.isSemanticError()
            && !rightFactor.isSemanticError())
            {
                rightFactor.generateRightValue();
                Code.put(op);
                if (leftFactor.isArrayElement())
                {
                    Code.put(Code.dup_x2);
                }
                else
                {
                    Code.put(Code.dup);
                }

                Code.store(leftFactor.getObj());
                leftFactor.setRightValue(true);
                RESULT = leftFactor;
            }
            else
            {
                // set errorr;
                RESULT = leftFactor.setSemanticError(true);
            }
        :}
        |
        MulopLeftFactor:type
        {:
            RESULT = type;
        :}
        ;

MulopLeftFactor ::=
        MulopLeftFactor:leftFactor
        MulopLeft:op
        Factor:rightFactor
        {:
            if (leftFactor.getObj().getType().equals(Tab.intType)
            && (rightFactor.getObj().getType().equals(Tab.intType)))
            {
                rightFactor.generateRightValue();
                Code.put(op);
                leftFactor.generateRightValue();
                RESULT = new ObjResultWrapper(new Obj(Obj.Con,"",Tab.intType), true);
            }
            else
            {
                RESULT = leftFactor.setSemanticError(true);
            }
        :}
        |
        Factor:factor
        {:
            // Do ovde dodje x : i : x[i]
            RESULT = factor;
        :}
        ;

/**********************   Factor     *****************************/
/*****************************************************************/

Factor ::=
        DesignatorFuncCall:func
        {:
            RESULT = func;
        :}
        |
        Designator:designator
        {:
            RESULT = designator;
        :}
        |
        ConstValue:constValue
        {:
            Code.load(constValue);
            RESULT = new ObjResultWrapper(constValue, true/*isRightValue*/);
        :}
        |
        NEW Type:type BracketExprEpsilon:isArray
        {:
            if (isArray)
            {
                Code.put(Code.newarray);
                // TODO: For classes which are non word alligned,
                // alloc using char
                //
                if (type.equals(Tab.charType))
                {
                    Code.put(0);
                }
                else
                {
                    Code.put(1);
                }
                Struct struct = new Struct(Struct.Array, type);
                RESULT = new ObjResultWrapper(new Obj(Obj.Con, "", struct), true);
            }
            else
            {
                // TODO : if it's class alloc as it is supposed to be.
                //
                if (type.equals(Tab.charType))
                {
                    Code.put(CHAR_SIZE);
                }
                else
                {
                    Code.put(INT_SIZE);
                }
            }
            // TO DO : Add check of errors.
            //
        :}
        |
        PAR_LEFT Expr:result PAR_RIGHT
        {:
            RESULT = result;
        :}
        ;
ParActParsEpsilonEpsilon ::=
            PAR_LEFT ActParsEpsilon PAR_RIGHT
            |
            /* epsilon */
            ;
BracketExprEpsilon ::=
            BRACKET_LEFT Expr BRACKET_RIGHT
            {:
                RESULT = true;
            :}
            |
            {:
                RESULT = false;
            :}
            /* epsilon */
            ;


/**********************   Designator   ***************************/
/*****************************************************************/
Designator ::=
            IDENT:name
            {:
                Obj obj = Tab.find(name);

                curObjWrappFieldOrElem = new ObjResultWrapper(obj, obj.getKind() == Obj.Con);
                listCurObjWrapperFieldOrElem.addLast(curObjWrappFieldOrElem);
                if (obj == Tab.noObj)
                {
                    curObjWrappFieldOrElem.setSemanticError(true);
                }
                else if (curObjWrappFieldOrElem.loadable())
                {
                    Code.load(curObjWrappFieldOrElem.getObj());
                }

            :}
            DotIdentOrBracketExprListEpsilon:objWrapper
            {:
                if ( (!curObjWrappFieldOrElem.isSemanticError())
                && (objWrapper == null))
                {

                    ObjResultWrapper objWrap = new ObjResultWrapper(curObjWrappFieldOrElem.getObj(), curObjWrappFieldOrElem.getObj().getKind() == Obj.Con);
                    RESULT = objWrap;
                }
                else if ( (objWrapper != null) && (!objWrapper.isSemanticError())
                && (!objWrapper.getObj().equals(Tab.noObj)) )
                {
                    RESULT = objWrapper;
                }
                else
                {
                    RESULT = curObjWrappFieldOrElem.setSemanticError(true);
                }
                listCurObjWrapperFieldOrElem.removeLast();
                if (listCurObjWrapperFieldOrElem.size() != 0)
                {
                    curObjWrappFieldOrElem = listCurObjWrapperFieldOrElem.getLast();
                }

            :}
            ;
DotIdentOrBracketExprListEpsilon ::=
            DotIdentOrBracketExprList:objWrap
            {:
                RESULT = objWrap;
            :}
            |
            {:
                RESULT = null;
            :}
            /* epsilon */
            ;
DotIdentOrBracketExprList ::=
            DotIdentOrBracketExprList:left DotIdentOrBracketExpr:objWrapper
            {:
                // TODO dodaj proveru da li je levo klasa ili niz (drugo nista ne moze...), i tek onda expandujes to ce ti biti nivo C, do tad ne brini (sledeca nedelja :O )
                if (left.isSemanticError() || objWrapper.isSemanticError())
                {
                    RESULT = objWrapper.setSemanticError(true);
                }
                else
                {
                    RESULT = objWrapper;
                }

            :}
            |
            DotIdentOrBracketExpr:objWrapper
            {:
                RESULT = objWrapper;
            :}
            ;
DotIdentOrBracketExpr ::=
        DOT IDENT
        |
        BRACKET_LEFT Expr BRACKET_RIGHT
        {:
            if (curObjWrappFieldOrElem.isArray())
            {
                Struct curArrayDotType = curObjWrappFieldOrElem.getObj().getType().getElemType();
                if ( !curObjWrappFieldOrElem.isSemanticError()
                    && !curArrayDotType.equals(Tab.noType))
                    {
                        // Add check for field..
                        //
                        Obj obj = new Obj(Obj.Elem, "", curArrayDotType);
                        curObjWrappFieldOrElem.setObj(obj);
                        Code.put(Code.dup2);
                        Code.load(obj);
                        RESULT = new ObjResultWrapper(obj, false /* RVALUE */);
                    }
                    else
                    {
                        RESULT = curObjWrappFieldOrElem.setSemanticError(true);
                    }
            }
            else
            {
                RESULT = curObjWrappFieldOrElem.setSemanticError(true);
            }
        :}
        |
        BRACKET_LEFT error BRACKET_RIGHT
        {:
            parser.report_error("Uspesan oporavak od greske kod indeksa niza,  BRACKET_RIGHT je resio stvar" , null);
        :}
        ;


/**********************   AssignOp    ****************************/
/*****************************************************************/
Assignop ::=
            OP_ASSIGN
            {:
                RESULT = OP_ASSIGN_CODE;
            :}
            |
            AddopRight:op
            {:
                RESULT = op;
            :}
            |
            MulopRight:op
            {:
                RESULT = op;
            :};


/**********************   Relop       ****************************/
/*****************************************************************/
Relop ::=
            OP_EQ
            {:
                RESULT = Code.eq;
            :}
            |
            OP_NOT_EQ
            {:
                RESULT = Code.ne;
            :}
            |
            OP_GTE
            {:
                RESULT = Code.ge;
            :}
            |
            OP_GREAT
            {:
                RESULT = Code.gt;
            :}
            |
            OP_LESS
            {:
                RESULT = Code.lt;
            :}
            |
            OP_LTE
            {:
                RESULT = Code.le;
            :}
            ;



/**********************   AddopLeft   ****************************/
/*****************************************************************/
AddopLeft ::=
            OP_ADD
            {:
                RESULT = Code.add;
            :}
            |
            OP_SUB
            {:
                RESULT = Code.sub;
            :}
            ;


/**********************   AddopRight  ****************************/
/*****************************************************************/
AddopRight ::=
            OP_ASSIGN_ADD
            {:
                RESULT = Code.add;
            :}
            |
            OP_ASSIGN_SUB
            {:
                RESULT = Code.sub;
            :}
            ;


/**********************   MulopLeft   ****************************/
/*****************************************************************/
MulopLeft ::=
            OP_MUL
            {:
                RESULT = Code.mul;
            :}
            |
            OP_DIV
            {:
                RESULT = Code.div;
            :}
            |
            OP_MOD
            {:
                RESULT = Code.rem;
            :}
            ;


/**********************   MulopRight  ****************************/
/*****************************************************************/
MulopRight ::=
            OP_ASSIGN_MUL
            {:
                RESULT = Code.mul;
            :}
            |
            OP_ASSIGN_DIV
            {:
                RESULT = Code.div;
            :}
            |
            OP_ASSIGN_MOD
            {:
                RESULT = Code.rem;
            :}
            ;

